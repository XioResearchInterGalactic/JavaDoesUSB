// Generated by jextract

package net.codecrete.usb.macos.gen.iokit;

import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
public class IOUSBInterfaceStruct942 {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("_reserved"),
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateInterfaceAsyncEventSource"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceAsyncEventSource"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateInterfaceAsyncPort"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceAsyncPort"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceOpen"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceClose"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceClass"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceSubClass"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceProtocol"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDeviceVendor"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDeviceProduct"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDeviceReleaseNumber"),
        Constants$root.C_POINTER$LAYOUT.withName("GetConfigurationValue"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceNumber"),
        Constants$root.C_POINTER$LAYOUT.withName("GetAlternateSetting"),
        Constants$root.C_POINTER$LAYOUT.withName("GetNumEndpoints"),
        Constants$root.C_POINTER$LAYOUT.withName("GetLocationID"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDevice"),
        Constants$root.C_POINTER$LAYOUT.withName("SetAlternateInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBusFrameNumber"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequest"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequestAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPipeProperties"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPipeStatus"),
        Constants$root.C_POINTER$LAYOUT.withName("AbortPipe"),
        Constants$root.C_POINTER$LAYOUT.withName("ResetPipe"),
        Constants$root.C_POINTER$LAYOUT.withName("ClearPipeStall"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipe"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipe"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadIsochPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("WriteIsochPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequestTO"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequestAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipeTO"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipeTO"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipeAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipeAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceGetStringIndex"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceOpenSeize"),
        Constants$root.C_POINTER$LAYOUT.withName("ClearPipeStallBothEnds"),
        Constants$root.C_POINTER$LAYOUT.withName("SetPipePolicy"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBandwidthAvailable"),
        Constants$root.C_POINTER$LAYOUT.withName("GetEndpointProperties"),
        Constants$root.C_POINTER$LAYOUT.withName("LowLatencyReadIsochPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("LowLatencyWriteIsochPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("LowLatencyCreateBuffer"),
        Constants$root.C_POINTER$LAYOUT.withName("LowLatencyDestroyBuffer"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBusMicroFrameNumber"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFrameListTime"),
        Constants$root.C_POINTER$LAYOUT.withName("GetIOUSBLibVersion"),
        Constants$root.C_POINTER$LAYOUT.withName("FindNextAssociatedDescriptor"),
        Constants$root.C_POINTER$LAYOUT.withName("FindNextAltInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBusFrameNumberWithTime"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPipePropertiesV2"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPipePropertiesV3"),
        Constants$root.C_POINTER$LAYOUT.withName("GetEndpointPropertiesV3"),
        Constants$root.C_POINTER$LAYOUT.withName("SupportsStreams"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateStreams"),
        Constants$root.C_POINTER$LAYOUT.withName("GetConfiguredStreams"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadStreamsPipeTO"),
        Constants$root.C_POINTER$LAYOUT.withName("WriteStreamsPipeTO"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadStreamsPipeAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("WriteStreamsPipeAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("AbortStreamsPipe"),
        Constants$root.C_POINTER$LAYOUT.withName("RegisterForNotification"),
        Constants$root.C_POINTER$LAYOUT.withName("UnregisterNotification"),
        Constants$root.C_POINTER$LAYOUT.withName("AcknowledgeNotification"),
        Constants$root.C_POINTER$LAYOUT.withName("RegisterDriver"),
        Constants$root.C_POINTER$LAYOUT.withName("SetDeviceIdlePolicy"),
        Constants$root.C_POINTER$LAYOUT.withName("SetPipeIdlePolicy"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceAsyncNotificationPort")
    ).withName("IOUSBInterfaceStruct942");
    public static MemoryLayout $LAYOUT() {
        return IOUSBInterfaceStruct942.$struct$LAYOUT;
    }
    static final VarHandle _reserved$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_reserved"));
    public static VarHandle _reserved$VH() {
        return IOUSBInterfaceStruct942._reserved$VH;
    }
    public static MemoryAddress _reserved$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942._reserved$VH.get(seg);
    }
    public static void _reserved$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942._reserved$VH.set(seg, x);
    }
    public static MemoryAddress _reserved$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942._reserved$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _reserved$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942._reserved$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        MemoryLayout.structLayout(
            Constants$root.C_CHAR$LAYOUT.withName("byte0"),
            Constants$root.C_CHAR$LAYOUT.withName("byte1"),
            Constants$root.C_CHAR$LAYOUT.withName("byte2"),
            Constants$root.C_CHAR$LAYOUT.withName("byte3"),
            Constants$root.C_CHAR$LAYOUT.withName("byte4"),
            Constants$root.C_CHAR$LAYOUT.withName("byte5"),
            Constants$root.C_CHAR$LAYOUT.withName("byte6"),
            Constants$root.C_CHAR$LAYOUT.withName("byte7"),
            Constants$root.C_CHAR$LAYOUT.withName("byte8"),
            Constants$root.C_CHAR$LAYOUT.withName("byte9"),
            Constants$root.C_CHAR$LAYOUT.withName("byte10"),
            Constants$root.C_CHAR$LAYOUT.withName("byte11"),
            Constants$root.C_CHAR$LAYOUT.withName("byte12"),
            Constants$root.C_CHAR$LAYOUT.withName("byte13"),
            Constants$root.C_CHAR$LAYOUT.withName("byte14"),
            Constants$root.C_CHAR$LAYOUT.withName("byte15")
        ),
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.QueryInterface$FUNC
    );
    public interface QueryInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(QueryInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IOUSBInterfaceStruct942.QueryInterface$FUNC, session);
        }
        static QueryInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.QueryInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IOUSBInterfaceStruct942.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment, MemorySession session) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), session);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.AddRef$FUNC
    );
    public interface AddRef {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(AddRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IOUSBInterfaceStruct942.AddRef$FUNC, session);
        }
        static AddRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.AddRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IOUSBInterfaceStruct942.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment, MemorySession session) {
        return AddRef.ofAddress(AddRef$get(segment), session);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.Release$FUNC
    );
    public interface Release {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Release fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Release.class, fi, IOUSBInterfaceStruct942.Release$FUNC, session);
        }
        static Release ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.Release$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IOUSBInterfaceStruct942.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment, MemorySession session) {
        return Release.ofAddress(Release$get(segment), session);
    }
    static final FunctionDescriptor CreateInterfaceAsyncEventSource$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CreateInterfaceAsyncEventSource$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$FUNC
    );
    public interface CreateInterfaceAsyncEventSource {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(CreateInterfaceAsyncEventSource fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateInterfaceAsyncEventSource.class, fi, IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$FUNC, session);
        }
        static CreateInterfaceAsyncEventSource ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateInterfaceAsyncEventSource$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateInterfaceAsyncEventSource"));
    public static VarHandle CreateInterfaceAsyncEventSource$VH() {
        return IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$VH;
    }
    public static MemoryAddress CreateInterfaceAsyncEventSource$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$VH.get(seg);
    }
    public static void CreateInterfaceAsyncEventSource$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$VH.set(seg, x);
    }
    public static MemoryAddress CreateInterfaceAsyncEventSource$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateInterfaceAsyncEventSource$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.CreateInterfaceAsyncEventSource$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateInterfaceAsyncEventSource CreateInterfaceAsyncEventSource (MemorySegment segment, MemorySession session) {
        return CreateInterfaceAsyncEventSource.ofAddress(CreateInterfaceAsyncEventSource$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceAsyncEventSource$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceAsyncEventSource$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$FUNC
    );
    public interface GetInterfaceAsyncEventSource {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(GetInterfaceAsyncEventSource fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceAsyncEventSource.class, fi, IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$FUNC, session);
        }
        static GetInterfaceAsyncEventSource ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceAsyncEventSource$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceAsyncEventSource"));
    public static VarHandle GetInterfaceAsyncEventSource$VH() {
        return IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$VH;
    }
    public static MemoryAddress GetInterfaceAsyncEventSource$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$VH.get(seg);
    }
    public static void GetInterfaceAsyncEventSource$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceAsyncEventSource$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceAsyncEventSource$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceAsyncEventSource$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceAsyncEventSource GetInterfaceAsyncEventSource (MemorySegment segment, MemorySession session) {
        return GetInterfaceAsyncEventSource.ofAddress(GetInterfaceAsyncEventSource$get(segment), session);
    }
    static final FunctionDescriptor CreateInterfaceAsyncPort$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CreateInterfaceAsyncPort$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$FUNC
    );
    public interface CreateInterfaceAsyncPort {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(CreateInterfaceAsyncPort fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateInterfaceAsyncPort.class, fi, IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$FUNC, session);
        }
        static CreateInterfaceAsyncPort ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateInterfaceAsyncPort$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateInterfaceAsyncPort"));
    public static VarHandle CreateInterfaceAsyncPort$VH() {
        return IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$VH;
    }
    public static MemoryAddress CreateInterfaceAsyncPort$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$VH.get(seg);
    }
    public static void CreateInterfaceAsyncPort$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$VH.set(seg, x);
    }
    public static MemoryAddress CreateInterfaceAsyncPort$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateInterfaceAsyncPort$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.CreateInterfaceAsyncPort$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateInterfaceAsyncPort CreateInterfaceAsyncPort (MemorySegment segment, MemorySession session) {
        return CreateInterfaceAsyncPort.ofAddress(CreateInterfaceAsyncPort$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceAsyncPort$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceAsyncPort$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetInterfaceAsyncPort$FUNC
    );
    public interface GetInterfaceAsyncPort {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(GetInterfaceAsyncPort fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceAsyncPort.class, fi, IOUSBInterfaceStruct942.GetInterfaceAsyncPort$FUNC, session);
        }
        static GetInterfaceAsyncPort ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetInterfaceAsyncPort$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceAsyncPort$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceAsyncPort"));
    public static VarHandle GetInterfaceAsyncPort$VH() {
        return IOUSBInterfaceStruct942.GetInterfaceAsyncPort$VH;
    }
    public static MemoryAddress GetInterfaceAsyncPort$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncPort$VH.get(seg);
    }
    public static void GetInterfaceAsyncPort$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceAsyncPort$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceAsyncPort$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncPort$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceAsyncPort$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceAsyncPort$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceAsyncPort GetInterfaceAsyncPort (MemorySegment segment, MemorySession session) {
        return GetInterfaceAsyncPort.ofAddress(GetInterfaceAsyncPort$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceOpen$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceOpen$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.USBInterfaceOpen$FUNC
    );
    public interface USBInterfaceOpen {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(USBInterfaceOpen fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceOpen.class, fi, IOUSBInterfaceStruct942.USBInterfaceOpen$FUNC, session);
        }
        static USBInterfaceOpen ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.USBInterfaceOpen$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceOpen$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceOpen"));
    public static VarHandle USBInterfaceOpen$VH() {
        return IOUSBInterfaceStruct942.USBInterfaceOpen$VH;
    }
    public static MemoryAddress USBInterfaceOpen$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceOpen$VH.get(seg);
    }
    public static void USBInterfaceOpen$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceOpen$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceOpen$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceOpen$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceOpen$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceOpen$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceOpen USBInterfaceOpen (MemorySegment segment, MemorySession session) {
        return USBInterfaceOpen.ofAddress(USBInterfaceOpen$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceClose$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceClose$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.USBInterfaceClose$FUNC
    );
    public interface USBInterfaceClose {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(USBInterfaceClose fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceClose.class, fi, IOUSBInterfaceStruct942.USBInterfaceClose$FUNC, session);
        }
        static USBInterfaceClose ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.USBInterfaceClose$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceClose$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceClose"));
    public static VarHandle USBInterfaceClose$VH() {
        return IOUSBInterfaceStruct942.USBInterfaceClose$VH;
    }
    public static MemoryAddress USBInterfaceClose$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceClose$VH.get(seg);
    }
    public static void USBInterfaceClose$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceClose$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceClose$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceClose$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceClose$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceClose$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceClose USBInterfaceClose (MemorySegment segment, MemorySession session) {
        return USBInterfaceClose.ofAddress(USBInterfaceClose$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceClass$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceClass$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetInterfaceClass$FUNC
    );
    public interface GetInterfaceClass {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceClass.class, fi, IOUSBInterfaceStruct942.GetInterfaceClass$FUNC, session);
        }
        static GetInterfaceClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetInterfaceClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceClass"));
    public static VarHandle GetInterfaceClass$VH() {
        return IOUSBInterfaceStruct942.GetInterfaceClass$VH;
    }
    public static MemoryAddress GetInterfaceClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceClass$VH.get(seg);
    }
    public static void GetInterfaceClass$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceClass$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceClass$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceClass GetInterfaceClass (MemorySegment segment, MemorySession session) {
        return GetInterfaceClass.ofAddress(GetInterfaceClass$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceSubClass$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceSubClass$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetInterfaceSubClass$FUNC
    );
    public interface GetInterfaceSubClass {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceSubClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceSubClass.class, fi, IOUSBInterfaceStruct942.GetInterfaceSubClass$FUNC, session);
        }
        static GetInterfaceSubClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetInterfaceSubClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceSubClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceSubClass"));
    public static VarHandle GetInterfaceSubClass$VH() {
        return IOUSBInterfaceStruct942.GetInterfaceSubClass$VH;
    }
    public static MemoryAddress GetInterfaceSubClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceSubClass$VH.get(seg);
    }
    public static void GetInterfaceSubClass$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceSubClass$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceSubClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceSubClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceSubClass$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceSubClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceSubClass GetInterfaceSubClass (MemorySegment segment, MemorySession session) {
        return GetInterfaceSubClass.ofAddress(GetInterfaceSubClass$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceProtocol$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceProtocol$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetInterfaceProtocol$FUNC
    );
    public interface GetInterfaceProtocol {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceProtocol fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceProtocol.class, fi, IOUSBInterfaceStruct942.GetInterfaceProtocol$FUNC, session);
        }
        static GetInterfaceProtocol ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetInterfaceProtocol$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceProtocol$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceProtocol"));
    public static VarHandle GetInterfaceProtocol$VH() {
        return IOUSBInterfaceStruct942.GetInterfaceProtocol$VH;
    }
    public static MemoryAddress GetInterfaceProtocol$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceProtocol$VH.get(seg);
    }
    public static void GetInterfaceProtocol$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceProtocol$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceProtocol$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceProtocol$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceProtocol$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceProtocol$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceProtocol GetInterfaceProtocol (MemorySegment segment, MemorySession session) {
        return GetInterfaceProtocol.ofAddress(GetInterfaceProtocol$get(segment), session);
    }
    static final FunctionDescriptor GetDeviceVendor$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDeviceVendor$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetDeviceVendor$FUNC
    );
    public interface GetDeviceVendor {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDeviceVendor fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDeviceVendor.class, fi, IOUSBInterfaceStruct942.GetDeviceVendor$FUNC, session);
        }
        static GetDeviceVendor ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetDeviceVendor$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDeviceVendor$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDeviceVendor"));
    public static VarHandle GetDeviceVendor$VH() {
        return IOUSBInterfaceStruct942.GetDeviceVendor$VH;
    }
    public static MemoryAddress GetDeviceVendor$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDeviceVendor$VH.get(seg);
    }
    public static void GetDeviceVendor$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDeviceVendor$VH.set(seg, x);
    }
    public static MemoryAddress GetDeviceVendor$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDeviceVendor$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDeviceVendor$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDeviceVendor$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDeviceVendor GetDeviceVendor (MemorySegment segment, MemorySession session) {
        return GetDeviceVendor.ofAddress(GetDeviceVendor$get(segment), session);
    }
    static final FunctionDescriptor GetDeviceProduct$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDeviceProduct$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetDeviceProduct$FUNC
    );
    public interface GetDeviceProduct {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDeviceProduct fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDeviceProduct.class, fi, IOUSBInterfaceStruct942.GetDeviceProduct$FUNC, session);
        }
        static GetDeviceProduct ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetDeviceProduct$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDeviceProduct$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDeviceProduct"));
    public static VarHandle GetDeviceProduct$VH() {
        return IOUSBInterfaceStruct942.GetDeviceProduct$VH;
    }
    public static MemoryAddress GetDeviceProduct$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDeviceProduct$VH.get(seg);
    }
    public static void GetDeviceProduct$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDeviceProduct$VH.set(seg, x);
    }
    public static MemoryAddress GetDeviceProduct$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDeviceProduct$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDeviceProduct$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDeviceProduct$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDeviceProduct GetDeviceProduct (MemorySegment segment, MemorySession session) {
        return GetDeviceProduct.ofAddress(GetDeviceProduct$get(segment), session);
    }
    static final FunctionDescriptor GetDeviceReleaseNumber$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDeviceReleaseNumber$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetDeviceReleaseNumber$FUNC
    );
    public interface GetDeviceReleaseNumber {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDeviceReleaseNumber fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDeviceReleaseNumber.class, fi, IOUSBInterfaceStruct942.GetDeviceReleaseNumber$FUNC, session);
        }
        static GetDeviceReleaseNumber ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetDeviceReleaseNumber$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDeviceReleaseNumber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDeviceReleaseNumber"));
    public static VarHandle GetDeviceReleaseNumber$VH() {
        return IOUSBInterfaceStruct942.GetDeviceReleaseNumber$VH;
    }
    public static MemoryAddress GetDeviceReleaseNumber$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDeviceReleaseNumber$VH.get(seg);
    }
    public static void GetDeviceReleaseNumber$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDeviceReleaseNumber$VH.set(seg, x);
    }
    public static MemoryAddress GetDeviceReleaseNumber$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDeviceReleaseNumber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDeviceReleaseNumber$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDeviceReleaseNumber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDeviceReleaseNumber GetDeviceReleaseNumber (MemorySegment segment, MemorySession session) {
        return GetDeviceReleaseNumber.ofAddress(GetDeviceReleaseNumber$get(segment), session);
    }
    static final FunctionDescriptor GetConfigurationValue$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetConfigurationValue$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetConfigurationValue$FUNC
    );
    public interface GetConfigurationValue {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetConfigurationValue fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetConfigurationValue.class, fi, IOUSBInterfaceStruct942.GetConfigurationValue$FUNC, session);
        }
        static GetConfigurationValue ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetConfigurationValue$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetConfigurationValue$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetConfigurationValue"));
    public static VarHandle GetConfigurationValue$VH() {
        return IOUSBInterfaceStruct942.GetConfigurationValue$VH;
    }
    public static MemoryAddress GetConfigurationValue$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetConfigurationValue$VH.get(seg);
    }
    public static void GetConfigurationValue$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetConfigurationValue$VH.set(seg, x);
    }
    public static MemoryAddress GetConfigurationValue$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetConfigurationValue$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetConfigurationValue$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetConfigurationValue$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetConfigurationValue GetConfigurationValue (MemorySegment segment, MemorySession session) {
        return GetConfigurationValue.ofAddress(GetConfigurationValue$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceNumber$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceNumber$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetInterfaceNumber$FUNC
    );
    public interface GetInterfaceNumber {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceNumber fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceNumber.class, fi, IOUSBInterfaceStruct942.GetInterfaceNumber$FUNC, session);
        }
        static GetInterfaceNumber ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetInterfaceNumber$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceNumber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceNumber"));
    public static VarHandle GetInterfaceNumber$VH() {
        return IOUSBInterfaceStruct942.GetInterfaceNumber$VH;
    }
    public static MemoryAddress GetInterfaceNumber$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceNumber$VH.get(seg);
    }
    public static void GetInterfaceNumber$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceNumber$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceNumber$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceNumber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceNumber$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceNumber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceNumber GetInterfaceNumber (MemorySegment segment, MemorySession session) {
        return GetInterfaceNumber.ofAddress(GetInterfaceNumber$get(segment), session);
    }
    static final FunctionDescriptor GetAlternateSetting$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetAlternateSetting$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetAlternateSetting$FUNC
    );
    public interface GetAlternateSetting {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetAlternateSetting fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetAlternateSetting.class, fi, IOUSBInterfaceStruct942.GetAlternateSetting$FUNC, session);
        }
        static GetAlternateSetting ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetAlternateSetting$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetAlternateSetting$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetAlternateSetting"));
    public static VarHandle GetAlternateSetting$VH() {
        return IOUSBInterfaceStruct942.GetAlternateSetting$VH;
    }
    public static MemoryAddress GetAlternateSetting$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetAlternateSetting$VH.get(seg);
    }
    public static void GetAlternateSetting$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetAlternateSetting$VH.set(seg, x);
    }
    public static MemoryAddress GetAlternateSetting$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetAlternateSetting$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetAlternateSetting$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetAlternateSetting$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetAlternateSetting GetAlternateSetting (MemorySegment segment, MemorySession session) {
        return GetAlternateSetting.ofAddress(GetAlternateSetting$get(segment), session);
    }
    static final FunctionDescriptor GetNumEndpoints$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetNumEndpoints$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetNumEndpoints$FUNC
    );
    public interface GetNumEndpoints {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetNumEndpoints fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetNumEndpoints.class, fi, IOUSBInterfaceStruct942.GetNumEndpoints$FUNC, session);
        }
        static GetNumEndpoints ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetNumEndpoints$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetNumEndpoints$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetNumEndpoints"));
    public static VarHandle GetNumEndpoints$VH() {
        return IOUSBInterfaceStruct942.GetNumEndpoints$VH;
    }
    public static MemoryAddress GetNumEndpoints$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetNumEndpoints$VH.get(seg);
    }
    public static void GetNumEndpoints$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetNumEndpoints$VH.set(seg, x);
    }
    public static MemoryAddress GetNumEndpoints$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetNumEndpoints$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetNumEndpoints$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetNumEndpoints$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetNumEndpoints GetNumEndpoints (MemorySegment segment, MemorySession session) {
        return GetNumEndpoints.ofAddress(GetNumEndpoints$get(segment), session);
    }
    static final FunctionDescriptor GetLocationID$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetLocationID$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetLocationID$FUNC
    );
    public interface GetLocationID {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetLocationID fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetLocationID.class, fi, IOUSBInterfaceStruct942.GetLocationID$FUNC, session);
        }
        static GetLocationID ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetLocationID$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetLocationID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetLocationID"));
    public static VarHandle GetLocationID$VH() {
        return IOUSBInterfaceStruct942.GetLocationID$VH;
    }
    public static MemoryAddress GetLocationID$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetLocationID$VH.get(seg);
    }
    public static void GetLocationID$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetLocationID$VH.set(seg, x);
    }
    public static MemoryAddress GetLocationID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetLocationID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetLocationID$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetLocationID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetLocationID GetLocationID (MemorySegment segment, MemorySession session) {
        return GetLocationID.ofAddress(GetLocationID$get(segment), session);
    }
    static final FunctionDescriptor GetDevice$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDevice$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetDevice$FUNC
    );
    public interface GetDevice {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDevice fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDevice.class, fi, IOUSBInterfaceStruct942.GetDevice$FUNC, session);
        }
        static GetDevice ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetDevice$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDevice$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDevice"));
    public static VarHandle GetDevice$VH() {
        return IOUSBInterfaceStruct942.GetDevice$VH;
    }
    public static MemoryAddress GetDevice$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDevice$VH.get(seg);
    }
    public static void GetDevice$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDevice$VH.set(seg, x);
    }
    public static MemoryAddress GetDevice$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetDevice$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDevice$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetDevice$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDevice GetDevice (MemorySegment segment, MemorySession session) {
        return GetDevice.ofAddress(GetDevice$get(segment), session);
    }
    static final FunctionDescriptor SetAlternateInterface$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetAlternateInterface$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.SetAlternateInterface$FUNC
    );
    public interface SetAlternateInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(SetAlternateInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetAlternateInterface.class, fi, IOUSBInterfaceStruct942.SetAlternateInterface$FUNC, session);
        }
        static SetAlternateInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.SetAlternateInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetAlternateInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetAlternateInterface"));
    public static VarHandle SetAlternateInterface$VH() {
        return IOUSBInterfaceStruct942.SetAlternateInterface$VH;
    }
    public static MemoryAddress SetAlternateInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetAlternateInterface$VH.get(seg);
    }
    public static void SetAlternateInterface$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetAlternateInterface$VH.set(seg, x);
    }
    public static MemoryAddress SetAlternateInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetAlternateInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetAlternateInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetAlternateInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetAlternateInterface SetAlternateInterface (MemorySegment segment, MemorySession session) {
        return SetAlternateInterface.ofAddress(SetAlternateInterface$get(segment), session);
    }
    static final FunctionDescriptor GetBusFrameNumber$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBusFrameNumber$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetBusFrameNumber$FUNC
    );
    public interface GetBusFrameNumber {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetBusFrameNumber fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBusFrameNumber.class, fi, IOUSBInterfaceStruct942.GetBusFrameNumber$FUNC, session);
        }
        static GetBusFrameNumber ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetBusFrameNumber$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBusFrameNumber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBusFrameNumber"));
    public static VarHandle GetBusFrameNumber$VH() {
        return IOUSBInterfaceStruct942.GetBusFrameNumber$VH;
    }
    public static MemoryAddress GetBusFrameNumber$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBusFrameNumber$VH.get(seg);
    }
    public static void GetBusFrameNumber$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBusFrameNumber$VH.set(seg, x);
    }
    public static MemoryAddress GetBusFrameNumber$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBusFrameNumber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBusFrameNumber$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBusFrameNumber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBusFrameNumber GetBusFrameNumber (MemorySegment segment, MemorySession session) {
        return GetBusFrameNumber.ofAddress(GetBusFrameNumber$get(segment), session);
    }
    static final FunctionDescriptor ControlRequest$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequest$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ControlRequest$FUNC
    );
    public interface ControlRequest {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ControlRequest fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequest.class, fi, IOUSBInterfaceStruct942.ControlRequest$FUNC, session);
        }
        static ControlRequest ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ControlRequest$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequest$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequest"));
    public static VarHandle ControlRequest$VH() {
        return IOUSBInterfaceStruct942.ControlRequest$VH;
    }
    public static MemoryAddress ControlRequest$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequest$VH.get(seg);
    }
    public static void ControlRequest$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequest$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequest$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequest$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequest$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequest$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequest ControlRequest (MemorySegment segment, MemorySession session) {
        return ControlRequest.ofAddress(ControlRequest$get(segment), session);
    }
    static final FunctionDescriptor ControlRequestAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequestAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ControlRequestAsync$FUNC
    );
    public interface ControlRequestAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(ControlRequestAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequestAsync.class, fi, IOUSBInterfaceStruct942.ControlRequestAsync$FUNC, session);
        }
        static ControlRequestAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ControlRequestAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequestAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequestAsync"));
    public static VarHandle ControlRequestAsync$VH() {
        return IOUSBInterfaceStruct942.ControlRequestAsync$VH;
    }
    public static MemoryAddress ControlRequestAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequestAsync$VH.get(seg);
    }
    public static void ControlRequestAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequestAsync$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequestAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequestAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequestAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequestAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequestAsync ControlRequestAsync (MemorySegment segment, MemorySession session) {
        return ControlRequestAsync.ofAddress(ControlRequestAsync$get(segment), session);
    }
    static final FunctionDescriptor GetPipeProperties$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPipeProperties$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetPipeProperties$FUNC
    );
    public interface GetPipeProperties {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(GetPipeProperties fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPipeProperties.class, fi, IOUSBInterfaceStruct942.GetPipeProperties$FUNC, session);
        }
        static GetPipeProperties ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetPipeProperties$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPipeProperties$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPipeProperties"));
    public static VarHandle GetPipeProperties$VH() {
        return IOUSBInterfaceStruct942.GetPipeProperties$VH;
    }
    public static MemoryAddress GetPipeProperties$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipeProperties$VH.get(seg);
    }
    public static void GetPipeProperties$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipeProperties$VH.set(seg, x);
    }
    public static MemoryAddress GetPipeProperties$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipeProperties$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPipeProperties$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipeProperties$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPipeProperties GetPipeProperties (MemorySegment segment, MemorySession session) {
        return GetPipeProperties.ofAddress(GetPipeProperties$get(segment), session);
    }
    static final FunctionDescriptor GetPipeStatus$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle GetPipeStatus$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetPipeStatus$FUNC
    );
    public interface GetPipeStatus {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(GetPipeStatus fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPipeStatus.class, fi, IOUSBInterfaceStruct942.GetPipeStatus$FUNC, session);
        }
        static GetPipeStatus ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetPipeStatus$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPipeStatus$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPipeStatus"));
    public static VarHandle GetPipeStatus$VH() {
        return IOUSBInterfaceStruct942.GetPipeStatus$VH;
    }
    public static MemoryAddress GetPipeStatus$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipeStatus$VH.get(seg);
    }
    public static void GetPipeStatus$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipeStatus$VH.set(seg, x);
    }
    public static MemoryAddress GetPipeStatus$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipeStatus$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPipeStatus$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipeStatus$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPipeStatus GetPipeStatus (MemorySegment segment, MemorySession session) {
        return GetPipeStatus.ofAddress(GetPipeStatus$get(segment), session);
    }
    static final FunctionDescriptor AbortPipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle AbortPipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.AbortPipe$FUNC
    );
    public interface AbortPipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(AbortPipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AbortPipe.class, fi, IOUSBInterfaceStruct942.AbortPipe$FUNC, session);
        }
        static AbortPipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.AbortPipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AbortPipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AbortPipe"));
    public static VarHandle AbortPipe$VH() {
        return IOUSBInterfaceStruct942.AbortPipe$VH;
    }
    public static MemoryAddress AbortPipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AbortPipe$VH.get(seg);
    }
    public static void AbortPipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.AbortPipe$VH.set(seg, x);
    }
    public static MemoryAddress AbortPipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AbortPipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AbortPipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.AbortPipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AbortPipe AbortPipe (MemorySegment segment, MemorySession session) {
        return AbortPipe.ofAddress(AbortPipe$get(segment), session);
    }
    static final FunctionDescriptor ResetPipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ResetPipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ResetPipe$FUNC
    );
    public interface ResetPipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(ResetPipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ResetPipe.class, fi, IOUSBInterfaceStruct942.ResetPipe$FUNC, session);
        }
        static ResetPipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ResetPipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ResetPipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ResetPipe"));
    public static VarHandle ResetPipe$VH() {
        return IOUSBInterfaceStruct942.ResetPipe$VH;
    }
    public static MemoryAddress ResetPipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ResetPipe$VH.get(seg);
    }
    public static void ResetPipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ResetPipe$VH.set(seg, x);
    }
    public static MemoryAddress ResetPipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ResetPipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ResetPipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ResetPipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ResetPipe ResetPipe (MemorySegment segment, MemorySession session) {
        return ResetPipe.ofAddress(ResetPipe$get(segment), session);
    }
    static final FunctionDescriptor ClearPipeStall$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ClearPipeStall$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ClearPipeStall$FUNC
    );
    public interface ClearPipeStall {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(ClearPipeStall fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ClearPipeStall.class, fi, IOUSBInterfaceStruct942.ClearPipeStall$FUNC, session);
        }
        static ClearPipeStall ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ClearPipeStall$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ClearPipeStall$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ClearPipeStall"));
    public static VarHandle ClearPipeStall$VH() {
        return IOUSBInterfaceStruct942.ClearPipeStall$VH;
    }
    public static MemoryAddress ClearPipeStall$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ClearPipeStall$VH.get(seg);
    }
    public static void ClearPipeStall$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ClearPipeStall$VH.set(seg, x);
    }
    public static MemoryAddress ClearPipeStall$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ClearPipeStall$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ClearPipeStall$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ClearPipeStall$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ClearPipeStall ClearPipeStall (MemorySegment segment, MemorySession session) {
        return ClearPipeStall.ofAddress(ClearPipeStall$get(segment), session);
    }
    static final FunctionDescriptor ReadPipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadPipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ReadPipe$FUNC
    );
    public interface ReadPipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(ReadPipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipe.class, fi, IOUSBInterfaceStruct942.ReadPipe$FUNC, session);
        }
        static ReadPipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ReadPipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipe"));
    public static VarHandle ReadPipe$VH() {
        return IOUSBInterfaceStruct942.ReadPipe$VH;
    }
    public static MemoryAddress ReadPipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipe$VH.get(seg);
    }
    public static void ReadPipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipe$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipe ReadPipe (MemorySegment segment, MemorySession session) {
        return ReadPipe.ofAddress(ReadPipe$get(segment), session);
    }
    static final FunctionDescriptor WritePipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle WritePipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.WritePipe$FUNC
    );
    public interface WritePipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(WritePipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipe.class, fi, IOUSBInterfaceStruct942.WritePipe$FUNC, session);
        }
        static WritePipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.WritePipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipe"));
    public static VarHandle WritePipe$VH() {
        return IOUSBInterfaceStruct942.WritePipe$VH;
    }
    public static MemoryAddress WritePipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipe$VH.get(seg);
    }
    public static void WritePipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipe$VH.set(seg, x);
    }
    public static MemoryAddress WritePipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipe WritePipe (MemorySegment segment, MemorySession session) {
        return WritePipe.ofAddress(WritePipe$get(segment), session);
    }
    static final FunctionDescriptor ReadPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ReadPipeAsync$FUNC
    );
    public interface ReadPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(ReadPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipeAsync.class, fi, IOUSBInterfaceStruct942.ReadPipeAsync$FUNC, session);
        }
        static ReadPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ReadPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipeAsync"));
    public static VarHandle ReadPipeAsync$VH() {
        return IOUSBInterfaceStruct942.ReadPipeAsync$VH;
    }
    public static MemoryAddress ReadPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipeAsync$VH.get(seg);
    }
    public static void ReadPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipeAsync ReadPipeAsync (MemorySegment segment, MemorySession session) {
        return ReadPipeAsync.ofAddress(ReadPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor WritePipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WritePipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.WritePipeAsync$FUNC
    );
    public interface WritePipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(WritePipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipeAsync.class, fi, IOUSBInterfaceStruct942.WritePipeAsync$FUNC, session);
        }
        static WritePipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.WritePipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipeAsync"));
    public static VarHandle WritePipeAsync$VH() {
        return IOUSBInterfaceStruct942.WritePipeAsync$VH;
    }
    public static MemoryAddress WritePipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipeAsync$VH.get(seg);
    }
    public static void WritePipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress WritePipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipeAsync WritePipeAsync (MemorySegment segment, MemorySession session) {
        return WritePipeAsync.ofAddress(WritePipeAsync$get(segment), session);
    }
    static final FunctionDescriptor ReadIsochPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadIsochPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ReadIsochPipeAsync$FUNC
    );
    public interface ReadIsochPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, long _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(ReadIsochPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadIsochPipeAsync.class, fi, IOUSBInterfaceStruct942.ReadIsochPipeAsync$FUNC, session);
        }
        static ReadIsochPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, long __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ReadIsochPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadIsochPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadIsochPipeAsync"));
    public static VarHandle ReadIsochPipeAsync$VH() {
        return IOUSBInterfaceStruct942.ReadIsochPipeAsync$VH;
    }
    public static MemoryAddress ReadIsochPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadIsochPipeAsync$VH.get(seg);
    }
    public static void ReadIsochPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadIsochPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress ReadIsochPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadIsochPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadIsochPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadIsochPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadIsochPipeAsync ReadIsochPipeAsync (MemorySegment segment, MemorySession session) {
        return ReadIsochPipeAsync.ofAddress(ReadIsochPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor WriteIsochPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WriteIsochPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.WriteIsochPipeAsync$FUNC
    );
    public interface WriteIsochPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, long _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(WriteIsochPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WriteIsochPipeAsync.class, fi, IOUSBInterfaceStruct942.WriteIsochPipeAsync$FUNC, session);
        }
        static WriteIsochPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, long __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.WriteIsochPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WriteIsochPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WriteIsochPipeAsync"));
    public static VarHandle WriteIsochPipeAsync$VH() {
        return IOUSBInterfaceStruct942.WriteIsochPipeAsync$VH;
    }
    public static MemoryAddress WriteIsochPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WriteIsochPipeAsync$VH.get(seg);
    }
    public static void WriteIsochPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.WriteIsochPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress WriteIsochPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WriteIsochPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WriteIsochPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.WriteIsochPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WriteIsochPipeAsync WriteIsochPipeAsync (MemorySegment segment, MemorySession session) {
        return WriteIsochPipeAsync.ofAddress(WriteIsochPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor ControlRequestTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequestTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ControlRequestTO$FUNC
    );
    public interface ControlRequestTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ControlRequestTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequestTO.class, fi, IOUSBInterfaceStruct942.ControlRequestTO$FUNC, session);
        }
        static ControlRequestTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ControlRequestTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequestTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequestTO"));
    public static VarHandle ControlRequestTO$VH() {
        return IOUSBInterfaceStruct942.ControlRequestTO$VH;
    }
    public static MemoryAddress ControlRequestTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequestTO$VH.get(seg);
    }
    public static void ControlRequestTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequestTO$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequestTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequestTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequestTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequestTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequestTO ControlRequestTO (MemorySegment segment, MemorySession session) {
        return ControlRequestTO.ofAddress(ControlRequestTO$get(segment), session);
    }
    static final FunctionDescriptor ControlRequestAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequestAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ControlRequestAsyncTO$FUNC
    );
    public interface ControlRequestAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(ControlRequestAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequestAsyncTO.class, fi, IOUSBInterfaceStruct942.ControlRequestAsyncTO$FUNC, session);
        }
        static ControlRequestAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ControlRequestAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequestAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequestAsyncTO"));
    public static VarHandle ControlRequestAsyncTO$VH() {
        return IOUSBInterfaceStruct942.ControlRequestAsyncTO$VH;
    }
    public static MemoryAddress ControlRequestAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequestAsyncTO$VH.get(seg);
    }
    public static void ControlRequestAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequestAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequestAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ControlRequestAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequestAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ControlRequestAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequestAsyncTO ControlRequestAsyncTO (MemorySegment segment, MemorySession session) {
        return ControlRequestAsyncTO.ofAddress(ControlRequestAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor ReadPipeTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReadPipeTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ReadPipeTO$FUNC
    );
    public interface ReadPipeTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, int _x4, int _x5);
        static MemorySegment allocate(ReadPipeTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipeTO.class, fi, IOUSBInterfaceStruct942.ReadPipeTO$FUNC, session);
        }
        static ReadPipeTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, int __x4, int __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ReadPipeTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipeTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipeTO"));
    public static VarHandle ReadPipeTO$VH() {
        return IOUSBInterfaceStruct942.ReadPipeTO$VH;
    }
    public static MemoryAddress ReadPipeTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipeTO$VH.get(seg);
    }
    public static void ReadPipeTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipeTO$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipeTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipeTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipeTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipeTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipeTO ReadPipeTO (MemorySegment segment, MemorySession session) {
        return ReadPipeTO.ofAddress(ReadPipeTO$get(segment), session);
    }
    static final FunctionDescriptor WritePipeTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle WritePipeTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.WritePipeTO$FUNC
    );
    public interface WritePipeTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, int _x4, int _x5);
        static MemorySegment allocate(WritePipeTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipeTO.class, fi, IOUSBInterfaceStruct942.WritePipeTO$FUNC, session);
        }
        static WritePipeTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, int __x4, int __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.WritePipeTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipeTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipeTO"));
    public static VarHandle WritePipeTO$VH() {
        return IOUSBInterfaceStruct942.WritePipeTO$VH;
    }
    public static MemoryAddress WritePipeTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipeTO$VH.get(seg);
    }
    public static void WritePipeTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipeTO$VH.set(seg, x);
    }
    public static MemoryAddress WritePipeTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipeTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipeTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipeTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipeTO WritePipeTO (MemorySegment segment, MemorySession session) {
        return WritePipeTO.ofAddress(WritePipeTO$get(segment), session);
    }
    static final FunctionDescriptor ReadPipeAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadPipeAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ReadPipeAsyncTO$FUNC
    );
    public interface ReadPipeAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, int _x4, int _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(ReadPipeAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipeAsyncTO.class, fi, IOUSBInterfaceStruct942.ReadPipeAsyncTO$FUNC, session);
        }
        static ReadPipeAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, int __x4, int __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ReadPipeAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipeAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipeAsyncTO"));
    public static VarHandle ReadPipeAsyncTO$VH() {
        return IOUSBInterfaceStruct942.ReadPipeAsyncTO$VH;
    }
    public static MemoryAddress ReadPipeAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipeAsyncTO$VH.get(seg);
    }
    public static void ReadPipeAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipeAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipeAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadPipeAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipeAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadPipeAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipeAsyncTO ReadPipeAsyncTO (MemorySegment segment, MemorySession session) {
        return ReadPipeAsyncTO.ofAddress(ReadPipeAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor WritePipeAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WritePipeAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.WritePipeAsyncTO$FUNC
    );
    public interface WritePipeAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, int _x4, int _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(WritePipeAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipeAsyncTO.class, fi, IOUSBInterfaceStruct942.WritePipeAsyncTO$FUNC, session);
        }
        static WritePipeAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, int __x4, int __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.WritePipeAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipeAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipeAsyncTO"));
    public static VarHandle WritePipeAsyncTO$VH() {
        return IOUSBInterfaceStruct942.WritePipeAsyncTO$VH;
    }
    public static MemoryAddress WritePipeAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipeAsyncTO$VH.get(seg);
    }
    public static void WritePipeAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipeAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress WritePipeAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WritePipeAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipeAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.WritePipeAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipeAsyncTO WritePipeAsyncTO (MemorySegment segment, MemorySession session) {
        return WritePipeAsyncTO.ofAddress(WritePipeAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceGetStringIndex$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceGetStringIndex$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$FUNC
    );
    public interface USBInterfaceGetStringIndex {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(USBInterfaceGetStringIndex fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceGetStringIndex.class, fi, IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$FUNC, session);
        }
        static USBInterfaceGetStringIndex ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceGetStringIndex$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceGetStringIndex"));
    public static VarHandle USBInterfaceGetStringIndex$VH() {
        return IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$VH;
    }
    public static MemoryAddress USBInterfaceGetStringIndex$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$VH.get(seg);
    }
    public static void USBInterfaceGetStringIndex$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceGetStringIndex$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceGetStringIndex$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceGetStringIndex$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceGetStringIndex USBInterfaceGetStringIndex (MemorySegment segment, MemorySession session) {
        return USBInterfaceGetStringIndex.ofAddress(USBInterfaceGetStringIndex$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceOpenSeize$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceOpenSeize$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.USBInterfaceOpenSeize$FUNC
    );
    public interface USBInterfaceOpenSeize {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(USBInterfaceOpenSeize fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceOpenSeize.class, fi, IOUSBInterfaceStruct942.USBInterfaceOpenSeize$FUNC, session);
        }
        static USBInterfaceOpenSeize ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.USBInterfaceOpenSeize$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceOpenSeize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceOpenSeize"));
    public static VarHandle USBInterfaceOpenSeize$VH() {
        return IOUSBInterfaceStruct942.USBInterfaceOpenSeize$VH;
    }
    public static MemoryAddress USBInterfaceOpenSeize$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceOpenSeize$VH.get(seg);
    }
    public static void USBInterfaceOpenSeize$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceOpenSeize$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceOpenSeize$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.USBInterfaceOpenSeize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceOpenSeize$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.USBInterfaceOpenSeize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceOpenSeize USBInterfaceOpenSeize (MemorySegment segment, MemorySession session) {
        return USBInterfaceOpenSeize.ofAddress(USBInterfaceOpenSeize$get(segment), session);
    }
    static final FunctionDescriptor ClearPipeStallBothEnds$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ClearPipeStallBothEnds$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ClearPipeStallBothEnds$FUNC
    );
    public interface ClearPipeStallBothEnds {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(ClearPipeStallBothEnds fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ClearPipeStallBothEnds.class, fi, IOUSBInterfaceStruct942.ClearPipeStallBothEnds$FUNC, session);
        }
        static ClearPipeStallBothEnds ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ClearPipeStallBothEnds$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ClearPipeStallBothEnds$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ClearPipeStallBothEnds"));
    public static VarHandle ClearPipeStallBothEnds$VH() {
        return IOUSBInterfaceStruct942.ClearPipeStallBothEnds$VH;
    }
    public static MemoryAddress ClearPipeStallBothEnds$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ClearPipeStallBothEnds$VH.get(seg);
    }
    public static void ClearPipeStallBothEnds$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ClearPipeStallBothEnds$VH.set(seg, x);
    }
    public static MemoryAddress ClearPipeStallBothEnds$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ClearPipeStallBothEnds$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ClearPipeStallBothEnds$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ClearPipeStallBothEnds$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ClearPipeStallBothEnds ClearPipeStallBothEnds (MemorySegment segment, MemorySession session) {
        return ClearPipeStallBothEnds.ofAddress(ClearPipeStallBothEnds$get(segment), session);
    }
    static final FunctionDescriptor SetPipePolicy$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetPipePolicy$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.SetPipePolicy$FUNC
    );
    public interface SetPipePolicy {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, short _x2, byte _x3);
        static MemorySegment allocate(SetPipePolicy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetPipePolicy.class, fi, IOUSBInterfaceStruct942.SetPipePolicy$FUNC, session);
        }
        static SetPipePolicy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, short __x2, byte __x3) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.SetPipePolicy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetPipePolicy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetPipePolicy"));
    public static VarHandle SetPipePolicy$VH() {
        return IOUSBInterfaceStruct942.SetPipePolicy$VH;
    }
    public static MemoryAddress SetPipePolicy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetPipePolicy$VH.get(seg);
    }
    public static void SetPipePolicy$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetPipePolicy$VH.set(seg, x);
    }
    public static MemoryAddress SetPipePolicy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetPipePolicy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetPipePolicy$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetPipePolicy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetPipePolicy SetPipePolicy (MemorySegment segment, MemorySession session) {
        return SetPipePolicy.ofAddress(SetPipePolicy$get(segment), session);
    }
    static final FunctionDescriptor GetBandwidthAvailable$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBandwidthAvailable$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetBandwidthAvailable$FUNC
    );
    public interface GetBandwidthAvailable {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetBandwidthAvailable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBandwidthAvailable.class, fi, IOUSBInterfaceStruct942.GetBandwidthAvailable$FUNC, session);
        }
        static GetBandwidthAvailable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetBandwidthAvailable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBandwidthAvailable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBandwidthAvailable"));
    public static VarHandle GetBandwidthAvailable$VH() {
        return IOUSBInterfaceStruct942.GetBandwidthAvailable$VH;
    }
    public static MemoryAddress GetBandwidthAvailable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBandwidthAvailable$VH.get(seg);
    }
    public static void GetBandwidthAvailable$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBandwidthAvailable$VH.set(seg, x);
    }
    public static MemoryAddress GetBandwidthAvailable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBandwidthAvailable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBandwidthAvailable$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBandwidthAvailable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBandwidthAvailable GetBandwidthAvailable (MemorySegment segment, MemorySession session) {
        return GetBandwidthAvailable.ofAddress(GetBandwidthAvailable$get(segment), session);
    }
    static final FunctionDescriptor GetEndpointProperties$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetEndpointProperties$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetEndpointProperties$FUNC
    );
    public interface GetEndpointProperties {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, byte _x2, byte _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(GetEndpointProperties fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetEndpointProperties.class, fi, IOUSBInterfaceStruct942.GetEndpointProperties$FUNC, session);
        }
        static GetEndpointProperties ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, byte __x2, byte __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetEndpointProperties$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetEndpointProperties$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetEndpointProperties"));
    public static VarHandle GetEndpointProperties$VH() {
        return IOUSBInterfaceStruct942.GetEndpointProperties$VH;
    }
    public static MemoryAddress GetEndpointProperties$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetEndpointProperties$VH.get(seg);
    }
    public static void GetEndpointProperties$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetEndpointProperties$VH.set(seg, x);
    }
    public static MemoryAddress GetEndpointProperties$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetEndpointProperties$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetEndpointProperties$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetEndpointProperties$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetEndpointProperties GetEndpointProperties (MemorySegment segment, MemorySession session) {
        return GetEndpointProperties.ofAddress(GetEndpointProperties$get(segment), session);
    }
    static final FunctionDescriptor LowLatencyReadIsochPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle LowLatencyReadIsochPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$FUNC
    );
    public interface LowLatencyReadIsochPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, long _x3, int _x4, int _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(LowLatencyReadIsochPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(LowLatencyReadIsochPipeAsync.class, fi, IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$FUNC, session);
        }
        static LowLatencyReadIsochPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, long __x3, int __x4, int __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle LowLatencyReadIsochPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("LowLatencyReadIsochPipeAsync"));
    public static VarHandle LowLatencyReadIsochPipeAsync$VH() {
        return IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$VH;
    }
    public static MemoryAddress LowLatencyReadIsochPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$VH.get(seg);
    }
    public static void LowLatencyReadIsochPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress LowLatencyReadIsochPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void LowLatencyReadIsochPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyReadIsochPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static LowLatencyReadIsochPipeAsync LowLatencyReadIsochPipeAsync (MemorySegment segment, MemorySession session) {
        return LowLatencyReadIsochPipeAsync.ofAddress(LowLatencyReadIsochPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor LowLatencyWriteIsochPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle LowLatencyWriteIsochPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$FUNC
    );
    public interface LowLatencyWriteIsochPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, long _x3, int _x4, int _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(LowLatencyWriteIsochPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(LowLatencyWriteIsochPipeAsync.class, fi, IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$FUNC, session);
        }
        static LowLatencyWriteIsochPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, long __x3, int __x4, int __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle LowLatencyWriteIsochPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("LowLatencyWriteIsochPipeAsync"));
    public static VarHandle LowLatencyWriteIsochPipeAsync$VH() {
        return IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$VH;
    }
    public static MemoryAddress LowLatencyWriteIsochPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$VH.get(seg);
    }
    public static void LowLatencyWriteIsochPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress LowLatencyWriteIsochPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void LowLatencyWriteIsochPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyWriteIsochPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static LowLatencyWriteIsochPipeAsync LowLatencyWriteIsochPipeAsync (MemorySegment segment, MemorySession session) {
        return LowLatencyWriteIsochPipeAsync.ofAddress(LowLatencyWriteIsochPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor LowLatencyCreateBuffer$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle LowLatencyCreateBuffer$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.LowLatencyCreateBuffer$FUNC
    );
    public interface LowLatencyCreateBuffer {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3);
        static MemorySegment allocate(LowLatencyCreateBuffer fi, MemorySession session) {
            return RuntimeHelper.upcallStub(LowLatencyCreateBuffer.class, fi, IOUSBInterfaceStruct942.LowLatencyCreateBuffer$FUNC, session);
        }
        static LowLatencyCreateBuffer ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.LowLatencyCreateBuffer$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle LowLatencyCreateBuffer$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("LowLatencyCreateBuffer"));
    public static VarHandle LowLatencyCreateBuffer$VH() {
        return IOUSBInterfaceStruct942.LowLatencyCreateBuffer$VH;
    }
    public static MemoryAddress LowLatencyCreateBuffer$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyCreateBuffer$VH.get(seg);
    }
    public static void LowLatencyCreateBuffer$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyCreateBuffer$VH.set(seg, x);
    }
    public static MemoryAddress LowLatencyCreateBuffer$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyCreateBuffer$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void LowLatencyCreateBuffer$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyCreateBuffer$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static LowLatencyCreateBuffer LowLatencyCreateBuffer (MemorySegment segment, MemorySession session) {
        return LowLatencyCreateBuffer.ofAddress(LowLatencyCreateBuffer$get(segment), session);
    }
    static final FunctionDescriptor LowLatencyDestroyBuffer$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle LowLatencyDestroyBuffer$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$FUNC
    );
    public interface LowLatencyDestroyBuffer {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(LowLatencyDestroyBuffer fi, MemorySession session) {
            return RuntimeHelper.upcallStub(LowLatencyDestroyBuffer.class, fi, IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$FUNC, session);
        }
        static LowLatencyDestroyBuffer ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle LowLatencyDestroyBuffer$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("LowLatencyDestroyBuffer"));
    public static VarHandle LowLatencyDestroyBuffer$VH() {
        return IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$VH;
    }
    public static MemoryAddress LowLatencyDestroyBuffer$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$VH.get(seg);
    }
    public static void LowLatencyDestroyBuffer$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$VH.set(seg, x);
    }
    public static MemoryAddress LowLatencyDestroyBuffer$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void LowLatencyDestroyBuffer$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.LowLatencyDestroyBuffer$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static LowLatencyDestroyBuffer LowLatencyDestroyBuffer (MemorySegment segment, MemorySession session) {
        return LowLatencyDestroyBuffer.ofAddress(LowLatencyDestroyBuffer$get(segment), session);
    }
    static final FunctionDescriptor GetBusMicroFrameNumber$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBusMicroFrameNumber$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetBusMicroFrameNumber$FUNC
    );
    public interface GetBusMicroFrameNumber {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetBusMicroFrameNumber fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBusMicroFrameNumber.class, fi, IOUSBInterfaceStruct942.GetBusMicroFrameNumber$FUNC, session);
        }
        static GetBusMicroFrameNumber ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetBusMicroFrameNumber$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBusMicroFrameNumber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBusMicroFrameNumber"));
    public static VarHandle GetBusMicroFrameNumber$VH() {
        return IOUSBInterfaceStruct942.GetBusMicroFrameNumber$VH;
    }
    public static MemoryAddress GetBusMicroFrameNumber$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBusMicroFrameNumber$VH.get(seg);
    }
    public static void GetBusMicroFrameNumber$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBusMicroFrameNumber$VH.set(seg, x);
    }
    public static MemoryAddress GetBusMicroFrameNumber$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBusMicroFrameNumber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBusMicroFrameNumber$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBusMicroFrameNumber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBusMicroFrameNumber GetBusMicroFrameNumber (MemorySegment segment, MemorySession session) {
        return GetBusMicroFrameNumber.ofAddress(GetBusMicroFrameNumber$get(segment), session);
    }
    static final FunctionDescriptor GetFrameListTime$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFrameListTime$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetFrameListTime$FUNC
    );
    public interface GetFrameListTime {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetFrameListTime fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFrameListTime.class, fi, IOUSBInterfaceStruct942.GetFrameListTime$FUNC, session);
        }
        static GetFrameListTime ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetFrameListTime$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFrameListTime$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFrameListTime"));
    public static VarHandle GetFrameListTime$VH() {
        return IOUSBInterfaceStruct942.GetFrameListTime$VH;
    }
    public static MemoryAddress GetFrameListTime$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetFrameListTime$VH.get(seg);
    }
    public static void GetFrameListTime$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetFrameListTime$VH.set(seg, x);
    }
    public static MemoryAddress GetFrameListTime$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetFrameListTime$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFrameListTime$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetFrameListTime$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFrameListTime GetFrameListTime (MemorySegment segment, MemorySession session) {
        return GetFrameListTime.ofAddress(GetFrameListTime$get(segment), session);
    }
    static final FunctionDescriptor GetIOUSBLibVersion$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetIOUSBLibVersion$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetIOUSBLibVersion$FUNC
    );
    public interface GetIOUSBLibVersion {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetIOUSBLibVersion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetIOUSBLibVersion.class, fi, IOUSBInterfaceStruct942.GetIOUSBLibVersion$FUNC, session);
        }
        static GetIOUSBLibVersion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetIOUSBLibVersion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetIOUSBLibVersion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetIOUSBLibVersion"));
    public static VarHandle GetIOUSBLibVersion$VH() {
        return IOUSBInterfaceStruct942.GetIOUSBLibVersion$VH;
    }
    public static MemoryAddress GetIOUSBLibVersion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetIOUSBLibVersion$VH.get(seg);
    }
    public static void GetIOUSBLibVersion$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetIOUSBLibVersion$VH.set(seg, x);
    }
    public static MemoryAddress GetIOUSBLibVersion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetIOUSBLibVersion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetIOUSBLibVersion$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetIOUSBLibVersion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetIOUSBLibVersion GetIOUSBLibVersion (MemorySegment segment, MemorySession session) {
        return GetIOUSBLibVersion.ofAddress(GetIOUSBLibVersion$get(segment), session);
    }
    static final FunctionDescriptor FindNextAssociatedDescriptor$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle FindNextAssociatedDescriptor$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$FUNC
    );
    public interface FindNextAssociatedDescriptor {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, byte _x2);
        static MemorySegment allocate(FindNextAssociatedDescriptor fi, MemorySession session) {
            return RuntimeHelper.upcallStub(FindNextAssociatedDescriptor.class, fi, IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$FUNC, session);
        }
        static FindNextAssociatedDescriptor ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, byte __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle FindNextAssociatedDescriptor$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("FindNextAssociatedDescriptor"));
    public static VarHandle FindNextAssociatedDescriptor$VH() {
        return IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$VH;
    }
    public static MemoryAddress FindNextAssociatedDescriptor$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$VH.get(seg);
    }
    public static void FindNextAssociatedDescriptor$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$VH.set(seg, x);
    }
    public static MemoryAddress FindNextAssociatedDescriptor$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void FindNextAssociatedDescriptor$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.FindNextAssociatedDescriptor$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static FindNextAssociatedDescriptor FindNextAssociatedDescriptor (MemorySegment segment, MemorySession session) {
        return FindNextAssociatedDescriptor.ofAddress(FindNextAssociatedDescriptor$get(segment), session);
    }
    static final FunctionDescriptor FindNextAltInterface$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle FindNextAltInterface$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.FindNextAltInterface$FUNC
    );
    public interface FindNextAltInterface {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(FindNextAltInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(FindNextAltInterface.class, fi, IOUSBInterfaceStruct942.FindNextAltInterface$FUNC, session);
        }
        static FindNextAltInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.FindNextAltInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle FindNextAltInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("FindNextAltInterface"));
    public static VarHandle FindNextAltInterface$VH() {
        return IOUSBInterfaceStruct942.FindNextAltInterface$VH;
    }
    public static MemoryAddress FindNextAltInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.FindNextAltInterface$VH.get(seg);
    }
    public static void FindNextAltInterface$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.FindNextAltInterface$VH.set(seg, x);
    }
    public static MemoryAddress FindNextAltInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.FindNextAltInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void FindNextAltInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.FindNextAltInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static FindNextAltInterface FindNextAltInterface (MemorySegment segment, MemorySession session) {
        return FindNextAltInterface.ofAddress(FindNextAltInterface$get(segment), session);
    }
    static final FunctionDescriptor GetBusFrameNumberWithTime$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBusFrameNumberWithTime$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$FUNC
    );
    public interface GetBusFrameNumberWithTime {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetBusFrameNumberWithTime fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBusFrameNumberWithTime.class, fi, IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$FUNC, session);
        }
        static GetBusFrameNumberWithTime ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBusFrameNumberWithTime$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBusFrameNumberWithTime"));
    public static VarHandle GetBusFrameNumberWithTime$VH() {
        return IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$VH;
    }
    public static MemoryAddress GetBusFrameNumberWithTime$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$VH.get(seg);
    }
    public static void GetBusFrameNumberWithTime$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$VH.set(seg, x);
    }
    public static MemoryAddress GetBusFrameNumberWithTime$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBusFrameNumberWithTime$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetBusFrameNumberWithTime$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBusFrameNumberWithTime GetBusFrameNumberWithTime (MemorySegment segment, MemorySession session) {
        return GetBusFrameNumberWithTime.ofAddress(GetBusFrameNumberWithTime$get(segment), session);
    }
    static final FunctionDescriptor GetPipePropertiesV2$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPipePropertiesV2$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetPipePropertiesV2$FUNC
    );
    public interface GetPipePropertiesV2 {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8, java.lang.foreign.MemoryAddress _x9);
        static MemorySegment allocate(GetPipePropertiesV2 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPipePropertiesV2.class, fi, IOUSBInterfaceStruct942.GetPipePropertiesV2$FUNC, session);
        }
        static GetPipePropertiesV2 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8, java.lang.foreign.MemoryAddress __x9) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetPipePropertiesV2$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8, (java.lang.foreign.Addressable)__x9);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPipePropertiesV2$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPipePropertiesV2"));
    public static VarHandle GetPipePropertiesV2$VH() {
        return IOUSBInterfaceStruct942.GetPipePropertiesV2$VH;
    }
    public static MemoryAddress GetPipePropertiesV2$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipePropertiesV2$VH.get(seg);
    }
    public static void GetPipePropertiesV2$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipePropertiesV2$VH.set(seg, x);
    }
    public static MemoryAddress GetPipePropertiesV2$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipePropertiesV2$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPipePropertiesV2$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipePropertiesV2$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPipePropertiesV2 GetPipePropertiesV2 (MemorySegment segment, MemorySession session) {
        return GetPipePropertiesV2.ofAddress(GetPipePropertiesV2$get(segment), session);
    }
    static final FunctionDescriptor GetPipePropertiesV3$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPipePropertiesV3$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetPipePropertiesV3$FUNC
    );
    public interface GetPipePropertiesV3 {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetPipePropertiesV3 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPipePropertiesV3.class, fi, IOUSBInterfaceStruct942.GetPipePropertiesV3$FUNC, session);
        }
        static GetPipePropertiesV3 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetPipePropertiesV3$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPipePropertiesV3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPipePropertiesV3"));
    public static VarHandle GetPipePropertiesV3$VH() {
        return IOUSBInterfaceStruct942.GetPipePropertiesV3$VH;
    }
    public static MemoryAddress GetPipePropertiesV3$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipePropertiesV3$VH.get(seg);
    }
    public static void GetPipePropertiesV3$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipePropertiesV3$VH.set(seg, x);
    }
    public static MemoryAddress GetPipePropertiesV3$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetPipePropertiesV3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPipePropertiesV3$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetPipePropertiesV3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPipePropertiesV3 GetPipePropertiesV3 (MemorySegment segment, MemorySession session) {
        return GetPipePropertiesV3.ofAddress(GetPipePropertiesV3$get(segment), session);
    }
    static final FunctionDescriptor GetEndpointPropertiesV3$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetEndpointPropertiesV3$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetEndpointPropertiesV3$FUNC
    );
    public interface GetEndpointPropertiesV3 {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetEndpointPropertiesV3 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetEndpointPropertiesV3.class, fi, IOUSBInterfaceStruct942.GetEndpointPropertiesV3$FUNC, session);
        }
        static GetEndpointPropertiesV3 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetEndpointPropertiesV3$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetEndpointPropertiesV3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetEndpointPropertiesV3"));
    public static VarHandle GetEndpointPropertiesV3$VH() {
        return IOUSBInterfaceStruct942.GetEndpointPropertiesV3$VH;
    }
    public static MemoryAddress GetEndpointPropertiesV3$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetEndpointPropertiesV3$VH.get(seg);
    }
    public static void GetEndpointPropertiesV3$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetEndpointPropertiesV3$VH.set(seg, x);
    }
    public static MemoryAddress GetEndpointPropertiesV3$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetEndpointPropertiesV3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetEndpointPropertiesV3$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetEndpointPropertiesV3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetEndpointPropertiesV3 GetEndpointPropertiesV3 (MemorySegment segment, MemorySession session) {
        return GetEndpointPropertiesV3.ofAddress(GetEndpointPropertiesV3$get(segment), session);
    }
    static final FunctionDescriptor SupportsStreams$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SupportsStreams$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.SupportsStreams$FUNC
    );
    public interface SupportsStreams {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(SupportsStreams fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SupportsStreams.class, fi, IOUSBInterfaceStruct942.SupportsStreams$FUNC, session);
        }
        static SupportsStreams ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.SupportsStreams$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SupportsStreams$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SupportsStreams"));
    public static VarHandle SupportsStreams$VH() {
        return IOUSBInterfaceStruct942.SupportsStreams$VH;
    }
    public static MemoryAddress SupportsStreams$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SupportsStreams$VH.get(seg);
    }
    public static void SupportsStreams$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.SupportsStreams$VH.set(seg, x);
    }
    public static MemoryAddress SupportsStreams$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SupportsStreams$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SupportsStreams$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.SupportsStreams$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SupportsStreams SupportsStreams (MemorySegment segment, MemorySession session) {
        return SupportsStreams.ofAddress(SupportsStreams$get(segment), session);
    }
    static final FunctionDescriptor CreateStreams$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle CreateStreams$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.CreateStreams$FUNC
    );
    public interface CreateStreams {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, int _x2);
        static MemorySegment allocate(CreateStreams fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateStreams.class, fi, IOUSBInterfaceStruct942.CreateStreams$FUNC, session);
        }
        static CreateStreams ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, int __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.CreateStreams$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateStreams$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateStreams"));
    public static VarHandle CreateStreams$VH() {
        return IOUSBInterfaceStruct942.CreateStreams$VH;
    }
    public static MemoryAddress CreateStreams$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.CreateStreams$VH.get(seg);
    }
    public static void CreateStreams$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.CreateStreams$VH.set(seg, x);
    }
    public static MemoryAddress CreateStreams$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.CreateStreams$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateStreams$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.CreateStreams$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateStreams CreateStreams (MemorySegment segment, MemorySession session) {
        return CreateStreams.ofAddress(CreateStreams$get(segment), session);
    }
    static final FunctionDescriptor GetConfiguredStreams$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetConfiguredStreams$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetConfiguredStreams$FUNC
    );
    public interface GetConfiguredStreams {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetConfiguredStreams fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetConfiguredStreams.class, fi, IOUSBInterfaceStruct942.GetConfiguredStreams$FUNC, session);
        }
        static GetConfiguredStreams ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.GetConfiguredStreams$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetConfiguredStreams$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetConfiguredStreams"));
    public static VarHandle GetConfiguredStreams$VH() {
        return IOUSBInterfaceStruct942.GetConfiguredStreams$VH;
    }
    public static MemoryAddress GetConfiguredStreams$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetConfiguredStreams$VH.get(seg);
    }
    public static void GetConfiguredStreams$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetConfiguredStreams$VH.set(seg, x);
    }
    public static MemoryAddress GetConfiguredStreams$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetConfiguredStreams$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetConfiguredStreams$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetConfiguredStreams$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetConfiguredStreams GetConfiguredStreams (MemorySegment segment, MemorySession session) {
        return GetConfiguredStreams.ofAddress(GetConfiguredStreams$get(segment), session);
    }
    static final FunctionDescriptor ReadStreamsPipeTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReadStreamsPipeTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ReadStreamsPipeTO$FUNC
    );
    public interface ReadStreamsPipeTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, int _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, int _x5, int _x6);
        static MemorySegment allocate(ReadStreamsPipeTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadStreamsPipeTO.class, fi, IOUSBInterfaceStruct942.ReadStreamsPipeTO$FUNC, session);
        }
        static ReadStreamsPipeTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, int __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, int __x5, int __x6) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ReadStreamsPipeTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, __x5, __x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadStreamsPipeTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadStreamsPipeTO"));
    public static VarHandle ReadStreamsPipeTO$VH() {
        return IOUSBInterfaceStruct942.ReadStreamsPipeTO$VH;
    }
    public static MemoryAddress ReadStreamsPipeTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadStreamsPipeTO$VH.get(seg);
    }
    public static void ReadStreamsPipeTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadStreamsPipeTO$VH.set(seg, x);
    }
    public static MemoryAddress ReadStreamsPipeTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadStreamsPipeTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadStreamsPipeTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadStreamsPipeTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadStreamsPipeTO ReadStreamsPipeTO (MemorySegment segment, MemorySession session) {
        return ReadStreamsPipeTO.ofAddress(ReadStreamsPipeTO$get(segment), session);
    }
    static final FunctionDescriptor WriteStreamsPipeTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle WriteStreamsPipeTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.WriteStreamsPipeTO$FUNC
    );
    public interface WriteStreamsPipeTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, int _x2, java.lang.foreign.MemoryAddress _x3, int _x4, int _x5, int _x6);
        static MemorySegment allocate(WriteStreamsPipeTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WriteStreamsPipeTO.class, fi, IOUSBInterfaceStruct942.WriteStreamsPipeTO$FUNC, session);
        }
        static WriteStreamsPipeTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, int __x2, java.lang.foreign.MemoryAddress __x3, int __x4, int __x5, int __x6) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.WriteStreamsPipeTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, __x4, __x5, __x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WriteStreamsPipeTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WriteStreamsPipeTO"));
    public static VarHandle WriteStreamsPipeTO$VH() {
        return IOUSBInterfaceStruct942.WriteStreamsPipeTO$VH;
    }
    public static MemoryAddress WriteStreamsPipeTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WriteStreamsPipeTO$VH.get(seg);
    }
    public static void WriteStreamsPipeTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.WriteStreamsPipeTO$VH.set(seg, x);
    }
    public static MemoryAddress WriteStreamsPipeTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WriteStreamsPipeTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WriteStreamsPipeTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.WriteStreamsPipeTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WriteStreamsPipeTO WriteStreamsPipeTO (MemorySegment segment, MemorySession session) {
        return WriteStreamsPipeTO.ofAddress(WriteStreamsPipeTO$get(segment), session);
    }
    static final FunctionDescriptor ReadStreamsPipeAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadStreamsPipeAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$FUNC
    );
    public interface ReadStreamsPipeAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, int _x2, java.lang.foreign.MemoryAddress _x3, int _x4, int _x5, int _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(ReadStreamsPipeAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadStreamsPipeAsyncTO.class, fi, IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$FUNC, session);
        }
        static ReadStreamsPipeAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, int __x2, java.lang.foreign.MemoryAddress __x3, int __x4, int __x5, int __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, __x4, __x5, __x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadStreamsPipeAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadStreamsPipeAsyncTO"));
    public static VarHandle ReadStreamsPipeAsyncTO$VH() {
        return IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$VH;
    }
    public static MemoryAddress ReadStreamsPipeAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$VH.get(seg);
    }
    public static void ReadStreamsPipeAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress ReadStreamsPipeAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadStreamsPipeAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.ReadStreamsPipeAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadStreamsPipeAsyncTO ReadStreamsPipeAsyncTO (MemorySegment segment, MemorySession session) {
        return ReadStreamsPipeAsyncTO.ofAddress(ReadStreamsPipeAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor WriteStreamsPipeAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WriteStreamsPipeAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$FUNC
    );
    public interface WriteStreamsPipeAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, int _x2, java.lang.foreign.MemoryAddress _x3, int _x4, int _x5, int _x6, java.lang.foreign.MemoryAddress _x7, java.lang.foreign.MemoryAddress _x8);
        static MemorySegment allocate(WriteStreamsPipeAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WriteStreamsPipeAsyncTO.class, fi, IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$FUNC, session);
        }
        static WriteStreamsPipeAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, int __x2, java.lang.foreign.MemoryAddress __x3, int __x4, int __x5, int __x6, java.lang.foreign.MemoryAddress __x7, java.lang.foreign.MemoryAddress __x8) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, (java.lang.foreign.Addressable)__x3, __x4, __x5, __x6, (java.lang.foreign.Addressable)__x7, (java.lang.foreign.Addressable)__x8);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WriteStreamsPipeAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WriteStreamsPipeAsyncTO"));
    public static VarHandle WriteStreamsPipeAsyncTO$VH() {
        return IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$VH;
    }
    public static MemoryAddress WriteStreamsPipeAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$VH.get(seg);
    }
    public static void WriteStreamsPipeAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress WriteStreamsPipeAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WriteStreamsPipeAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.WriteStreamsPipeAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WriteStreamsPipeAsyncTO WriteStreamsPipeAsyncTO (MemorySegment segment, MemorySession session) {
        return WriteStreamsPipeAsyncTO.ofAddress(WriteStreamsPipeAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor AbortStreamsPipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle AbortStreamsPipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.AbortStreamsPipe$FUNC
    );
    public interface AbortStreamsPipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, int _x2);
        static MemorySegment allocate(AbortStreamsPipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AbortStreamsPipe.class, fi, IOUSBInterfaceStruct942.AbortStreamsPipe$FUNC, session);
        }
        static AbortStreamsPipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, int __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.AbortStreamsPipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AbortStreamsPipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AbortStreamsPipe"));
    public static VarHandle AbortStreamsPipe$VH() {
        return IOUSBInterfaceStruct942.AbortStreamsPipe$VH;
    }
    public static MemoryAddress AbortStreamsPipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AbortStreamsPipe$VH.get(seg);
    }
    public static void AbortStreamsPipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.AbortStreamsPipe$VH.set(seg, x);
    }
    public static MemoryAddress AbortStreamsPipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AbortStreamsPipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AbortStreamsPipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.AbortStreamsPipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AbortStreamsPipe AbortStreamsPipe (MemorySegment segment, MemorySession session) {
        return AbortStreamsPipe.ofAddress(AbortStreamsPipe$get(segment), session);
    }
    static final FunctionDescriptor RegisterForNotification$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RegisterForNotification$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.RegisterForNotification$FUNC
    );
    public interface RegisterForNotification {

        int apply(java.lang.foreign.MemoryAddress _x0, long _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(RegisterForNotification fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RegisterForNotification.class, fi, IOUSBInterfaceStruct942.RegisterForNotification$FUNC, session);
        }
        static RegisterForNotification ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, long __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.RegisterForNotification$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RegisterForNotification$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RegisterForNotification"));
    public static VarHandle RegisterForNotification$VH() {
        return IOUSBInterfaceStruct942.RegisterForNotification$VH;
    }
    public static MemoryAddress RegisterForNotification$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.RegisterForNotification$VH.get(seg);
    }
    public static void RegisterForNotification$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.RegisterForNotification$VH.set(seg, x);
    }
    public static MemoryAddress RegisterForNotification$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.RegisterForNotification$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RegisterForNotification$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.RegisterForNotification$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RegisterForNotification RegisterForNotification (MemorySegment segment, MemorySession session) {
        return RegisterForNotification.ofAddress(RegisterForNotification$get(segment), session);
    }
    static final FunctionDescriptor UnregisterNotification$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle UnregisterNotification$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.UnregisterNotification$FUNC
    );
    public interface UnregisterNotification {

        int apply(java.lang.foreign.MemoryAddress _x0, long _x1);
        static MemorySegment allocate(UnregisterNotification fi, MemorySession session) {
            return RuntimeHelper.upcallStub(UnregisterNotification.class, fi, IOUSBInterfaceStruct942.UnregisterNotification$FUNC, session);
        }
        static UnregisterNotification ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, long __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.UnregisterNotification$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle UnregisterNotification$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("UnregisterNotification"));
    public static VarHandle UnregisterNotification$VH() {
        return IOUSBInterfaceStruct942.UnregisterNotification$VH;
    }
    public static MemoryAddress UnregisterNotification$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.UnregisterNotification$VH.get(seg);
    }
    public static void UnregisterNotification$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.UnregisterNotification$VH.set(seg, x);
    }
    public static MemoryAddress UnregisterNotification$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.UnregisterNotification$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void UnregisterNotification$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.UnregisterNotification$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static UnregisterNotification UnregisterNotification (MemorySegment segment, MemorySession session) {
        return UnregisterNotification.ofAddress(UnregisterNotification$get(segment), session);
    }
    static final FunctionDescriptor AcknowledgeNotification$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle AcknowledgeNotification$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.AcknowledgeNotification$FUNC
    );
    public interface AcknowledgeNotification {

        int apply(java.lang.foreign.MemoryAddress _x0, long _x1);
        static MemorySegment allocate(AcknowledgeNotification fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AcknowledgeNotification.class, fi, IOUSBInterfaceStruct942.AcknowledgeNotification$FUNC, session);
        }
        static AcknowledgeNotification ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, long __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.AcknowledgeNotification$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AcknowledgeNotification$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AcknowledgeNotification"));
    public static VarHandle AcknowledgeNotification$VH() {
        return IOUSBInterfaceStruct942.AcknowledgeNotification$VH;
    }
    public static MemoryAddress AcknowledgeNotification$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AcknowledgeNotification$VH.get(seg);
    }
    public static void AcknowledgeNotification$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.AcknowledgeNotification$VH.set(seg, x);
    }
    public static MemoryAddress AcknowledgeNotification$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.AcknowledgeNotification$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AcknowledgeNotification$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.AcknowledgeNotification$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AcknowledgeNotification AcknowledgeNotification (MemorySegment segment, MemorySession session) {
        return AcknowledgeNotification.ofAddress(AcknowledgeNotification$get(segment), session);
    }
    static final FunctionDescriptor RegisterDriver$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle RegisterDriver$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.RegisterDriver$FUNC
    );
    public interface RegisterDriver {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(RegisterDriver fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RegisterDriver.class, fi, IOUSBInterfaceStruct942.RegisterDriver$FUNC, session);
        }
        static RegisterDriver ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.RegisterDriver$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RegisterDriver$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RegisterDriver"));
    public static VarHandle RegisterDriver$VH() {
        return IOUSBInterfaceStruct942.RegisterDriver$VH;
    }
    public static MemoryAddress RegisterDriver$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.RegisterDriver$VH.get(seg);
    }
    public static void RegisterDriver$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.RegisterDriver$VH.set(seg, x);
    }
    public static MemoryAddress RegisterDriver$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.RegisterDriver$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RegisterDriver$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.RegisterDriver$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RegisterDriver RegisterDriver (MemorySegment segment, MemorySession session) {
        return RegisterDriver.ofAddress(RegisterDriver$get(segment), session);
    }
    static final FunctionDescriptor SetDeviceIdlePolicy$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle SetDeviceIdlePolicy$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.SetDeviceIdlePolicy$FUNC
    );
    public interface SetDeviceIdlePolicy {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(SetDeviceIdlePolicy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetDeviceIdlePolicy.class, fi, IOUSBInterfaceStruct942.SetDeviceIdlePolicy$FUNC, session);
        }
        static SetDeviceIdlePolicy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.SetDeviceIdlePolicy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetDeviceIdlePolicy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetDeviceIdlePolicy"));
    public static VarHandle SetDeviceIdlePolicy$VH() {
        return IOUSBInterfaceStruct942.SetDeviceIdlePolicy$VH;
    }
    public static MemoryAddress SetDeviceIdlePolicy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetDeviceIdlePolicy$VH.get(seg);
    }
    public static void SetDeviceIdlePolicy$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetDeviceIdlePolicy$VH.set(seg, x);
    }
    public static MemoryAddress SetDeviceIdlePolicy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetDeviceIdlePolicy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetDeviceIdlePolicy$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetDeviceIdlePolicy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetDeviceIdlePolicy SetDeviceIdlePolicy (MemorySegment segment, MemorySession session) {
        return SetDeviceIdlePolicy.ofAddress(SetDeviceIdlePolicy$get(segment), session);
    }
    static final FunctionDescriptor SetPipeIdlePolicy$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle SetPipeIdlePolicy$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.SetPipeIdlePolicy$FUNC
    );
    public interface SetPipeIdlePolicy {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, int _x2);
        static MemorySegment allocate(SetPipeIdlePolicy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetPipeIdlePolicy.class, fi, IOUSBInterfaceStruct942.SetPipeIdlePolicy$FUNC, session);
        }
        static SetPipeIdlePolicy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, int __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct942.SetPipeIdlePolicy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetPipeIdlePolicy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetPipeIdlePolicy"));
    public static VarHandle SetPipeIdlePolicy$VH() {
        return IOUSBInterfaceStruct942.SetPipeIdlePolicy$VH;
    }
    public static MemoryAddress SetPipeIdlePolicy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetPipeIdlePolicy$VH.get(seg);
    }
    public static void SetPipeIdlePolicy$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetPipeIdlePolicy$VH.set(seg, x);
    }
    public static MemoryAddress SetPipeIdlePolicy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.SetPipeIdlePolicy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetPipeIdlePolicy$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.SetPipeIdlePolicy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetPipeIdlePolicy SetPipeIdlePolicy (MemorySegment segment, MemorySession session) {
        return SetPipeIdlePolicy.ofAddress(SetPipeIdlePolicy$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceAsyncNotificationPort$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceAsyncNotificationPort$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$FUNC
    );
    public interface GetInterfaceAsyncNotificationPort {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(GetInterfaceAsyncNotificationPort fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceAsyncNotificationPort.class, fi, IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$FUNC, session);
        }
        static GetInterfaceAsyncNotificationPort ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceAsyncNotificationPort$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceAsyncNotificationPort"));
    public static VarHandle GetInterfaceAsyncNotificationPort$VH() {
        return IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$VH;
    }
    public static MemoryAddress GetInterfaceAsyncNotificationPort$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$VH.get(seg);
    }
    public static void GetInterfaceAsyncNotificationPort$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceAsyncNotificationPort$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceAsyncNotificationPort$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct942.GetInterfaceAsyncNotificationPort$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceAsyncNotificationPort GetInterfaceAsyncNotificationPort (MemorySegment segment, MemorySession session) {
        return GetInterfaceAsyncNotificationPort.ofAddress(GetInterfaceAsyncNotificationPort$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


