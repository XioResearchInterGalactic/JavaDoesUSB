// Generated by jextract

package net.codecrete.usb.macos.gen.iokit;

import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
public class IOUSBInterfaceStruct190 {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("_reserved"),
        Constants$root.C_POINTER$LAYOUT.withName("QueryInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("AddRef"),
        Constants$root.C_POINTER$LAYOUT.withName("Release"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateInterfaceAsyncEventSource"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceAsyncEventSource"),
        Constants$root.C_POINTER$LAYOUT.withName("CreateInterfaceAsyncPort"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceAsyncPort"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceOpen"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceClose"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceClass"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceSubClass"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceProtocol"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDeviceVendor"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDeviceProduct"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDeviceReleaseNumber"),
        Constants$root.C_POINTER$LAYOUT.withName("GetConfigurationValue"),
        Constants$root.C_POINTER$LAYOUT.withName("GetInterfaceNumber"),
        Constants$root.C_POINTER$LAYOUT.withName("GetAlternateSetting"),
        Constants$root.C_POINTER$LAYOUT.withName("GetNumEndpoints"),
        Constants$root.C_POINTER$LAYOUT.withName("GetLocationID"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDevice"),
        Constants$root.C_POINTER$LAYOUT.withName("SetAlternateInterface"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBusFrameNumber"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequest"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequestAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPipeProperties"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPipeStatus"),
        Constants$root.C_POINTER$LAYOUT.withName("AbortPipe"),
        Constants$root.C_POINTER$LAYOUT.withName("ResetPipe"),
        Constants$root.C_POINTER$LAYOUT.withName("ClearPipeStall"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipe"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipe"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadIsochPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("WriteIsochPipeAsync"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequestTO"),
        Constants$root.C_POINTER$LAYOUT.withName("ControlRequestAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipeTO"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipeTO"),
        Constants$root.C_POINTER$LAYOUT.withName("ReadPipeAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("WritePipeAsyncTO"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceGetStringIndex"),
        Constants$root.C_POINTER$LAYOUT.withName("USBInterfaceOpenSeize"),
        Constants$root.C_POINTER$LAYOUT.withName("ClearPipeStallBothEnds"),
        Constants$root.C_POINTER$LAYOUT.withName("SetPipePolicy"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBandwidthAvailable"),
        Constants$root.C_POINTER$LAYOUT.withName("GetEndpointProperties")
    ).withName("IOUSBInterfaceStruct190");
    public static MemoryLayout $LAYOUT() {
        return IOUSBInterfaceStruct190.$struct$LAYOUT;
    }
    static final VarHandle _reserved$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_reserved"));
    public static VarHandle _reserved$VH() {
        return IOUSBInterfaceStruct190._reserved$VH;
    }
    public static MemoryAddress _reserved$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190._reserved$VH.get(seg);
    }
    public static void _reserved$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190._reserved$VH.set(seg, x);
    }
    public static MemoryAddress _reserved$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190._reserved$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _reserved$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190._reserved$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor QueryInterface$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        MemoryLayout.structLayout(
            Constants$root.C_CHAR$LAYOUT.withName("byte0"),
            Constants$root.C_CHAR$LAYOUT.withName("byte1"),
            Constants$root.C_CHAR$LAYOUT.withName("byte2"),
            Constants$root.C_CHAR$LAYOUT.withName("byte3"),
            Constants$root.C_CHAR$LAYOUT.withName("byte4"),
            Constants$root.C_CHAR$LAYOUT.withName("byte5"),
            Constants$root.C_CHAR$LAYOUT.withName("byte6"),
            Constants$root.C_CHAR$LAYOUT.withName("byte7"),
            Constants$root.C_CHAR$LAYOUT.withName("byte8"),
            Constants$root.C_CHAR$LAYOUT.withName("byte9"),
            Constants$root.C_CHAR$LAYOUT.withName("byte10"),
            Constants$root.C_CHAR$LAYOUT.withName("byte11"),
            Constants$root.C_CHAR$LAYOUT.withName("byte12"),
            Constants$root.C_CHAR$LAYOUT.withName("byte13"),
            Constants$root.C_CHAR$LAYOUT.withName("byte14"),
            Constants$root.C_CHAR$LAYOUT.withName("byte15")
        ),
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle QueryInterface$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.QueryInterface$FUNC
    );
    public interface QueryInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(QueryInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(QueryInterface.class, fi, IOUSBInterfaceStruct190.QueryInterface$FUNC, session);
        }
        static QueryInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.QueryInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle QueryInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("QueryInterface"));
    public static VarHandle QueryInterface$VH() {
        return IOUSBInterfaceStruct190.QueryInterface$VH;
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.QueryInterface$VH.get(seg);
    }
    public static void QueryInterface$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.QueryInterface$VH.set(seg, x);
    }
    public static MemoryAddress QueryInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.QueryInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void QueryInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.QueryInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static QueryInterface QueryInterface (MemorySegment segment, MemorySession session) {
        return QueryInterface.ofAddress(QueryInterface$get(segment), session);
    }
    static final FunctionDescriptor AddRef$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AddRef$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.AddRef$FUNC
    );
    public interface AddRef {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(AddRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AddRef.class, fi, IOUSBInterfaceStruct190.AddRef$FUNC, session);
        }
        static AddRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.AddRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AddRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AddRef"));
    public static VarHandle AddRef$VH() {
        return IOUSBInterfaceStruct190.AddRef$VH;
    }
    public static MemoryAddress AddRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.AddRef$VH.get(seg);
    }
    public static void AddRef$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.AddRef$VH.set(seg, x);
    }
    public static MemoryAddress AddRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.AddRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AddRef$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.AddRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AddRef AddRef (MemorySegment segment, MemorySession session) {
        return AddRef.ofAddress(AddRef$get(segment), session);
    }
    static final FunctionDescriptor Release$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Release$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.Release$FUNC
    );
    public interface Release {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(Release fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Release.class, fi, IOUSBInterfaceStruct190.Release$FUNC, session);
        }
        static Release ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.Release$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Release"));
    public static VarHandle Release$VH() {
        return IOUSBInterfaceStruct190.Release$VH;
    }
    public static MemoryAddress Release$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.Release$VH.get(seg);
    }
    public static void Release$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.Release$VH.set(seg, x);
    }
    public static MemoryAddress Release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.Release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Release$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.Release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Release Release (MemorySegment segment, MemorySession session) {
        return Release.ofAddress(Release$get(segment), session);
    }
    static final FunctionDescriptor CreateInterfaceAsyncEventSource$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CreateInterfaceAsyncEventSource$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$FUNC
    );
    public interface CreateInterfaceAsyncEventSource {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(CreateInterfaceAsyncEventSource fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateInterfaceAsyncEventSource.class, fi, IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$FUNC, session);
        }
        static CreateInterfaceAsyncEventSource ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateInterfaceAsyncEventSource$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateInterfaceAsyncEventSource"));
    public static VarHandle CreateInterfaceAsyncEventSource$VH() {
        return IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$VH;
    }
    public static MemoryAddress CreateInterfaceAsyncEventSource$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$VH.get(seg);
    }
    public static void CreateInterfaceAsyncEventSource$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$VH.set(seg, x);
    }
    public static MemoryAddress CreateInterfaceAsyncEventSource$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateInterfaceAsyncEventSource$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.CreateInterfaceAsyncEventSource$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateInterfaceAsyncEventSource CreateInterfaceAsyncEventSource (MemorySegment segment, MemorySession session) {
        return CreateInterfaceAsyncEventSource.ofAddress(CreateInterfaceAsyncEventSource$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceAsyncEventSource$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceAsyncEventSource$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$FUNC
    );
    public interface GetInterfaceAsyncEventSource {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(GetInterfaceAsyncEventSource fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceAsyncEventSource.class, fi, IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$FUNC, session);
        }
        static GetInterfaceAsyncEventSource ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceAsyncEventSource$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceAsyncEventSource"));
    public static VarHandle GetInterfaceAsyncEventSource$VH() {
        return IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$VH;
    }
    public static MemoryAddress GetInterfaceAsyncEventSource$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$VH.get(seg);
    }
    public static void GetInterfaceAsyncEventSource$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceAsyncEventSource$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceAsyncEventSource$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceAsyncEventSource$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceAsyncEventSource GetInterfaceAsyncEventSource (MemorySegment segment, MemorySession session) {
        return GetInterfaceAsyncEventSource.ofAddress(GetInterfaceAsyncEventSource$get(segment), session);
    }
    static final FunctionDescriptor CreateInterfaceAsyncPort$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CreateInterfaceAsyncPort$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$FUNC
    );
    public interface CreateInterfaceAsyncPort {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(CreateInterfaceAsyncPort fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CreateInterfaceAsyncPort.class, fi, IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$FUNC, session);
        }
        static CreateInterfaceAsyncPort ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CreateInterfaceAsyncPort$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CreateInterfaceAsyncPort"));
    public static VarHandle CreateInterfaceAsyncPort$VH() {
        return IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$VH;
    }
    public static MemoryAddress CreateInterfaceAsyncPort$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$VH.get(seg);
    }
    public static void CreateInterfaceAsyncPort$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$VH.set(seg, x);
    }
    public static MemoryAddress CreateInterfaceAsyncPort$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CreateInterfaceAsyncPort$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.CreateInterfaceAsyncPort$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CreateInterfaceAsyncPort CreateInterfaceAsyncPort (MemorySegment segment, MemorySession session) {
        return CreateInterfaceAsyncPort.ofAddress(CreateInterfaceAsyncPort$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceAsyncPort$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceAsyncPort$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetInterfaceAsyncPort$FUNC
    );
    public interface GetInterfaceAsyncPort {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(GetInterfaceAsyncPort fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceAsyncPort.class, fi, IOUSBInterfaceStruct190.GetInterfaceAsyncPort$FUNC, session);
        }
        static GetInterfaceAsyncPort ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetInterfaceAsyncPort$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceAsyncPort$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceAsyncPort"));
    public static VarHandle GetInterfaceAsyncPort$VH() {
        return IOUSBInterfaceStruct190.GetInterfaceAsyncPort$VH;
    }
    public static MemoryAddress GetInterfaceAsyncPort$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceAsyncPort$VH.get(seg);
    }
    public static void GetInterfaceAsyncPort$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceAsyncPort$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceAsyncPort$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceAsyncPort$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceAsyncPort$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceAsyncPort$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceAsyncPort GetInterfaceAsyncPort (MemorySegment segment, MemorySession session) {
        return GetInterfaceAsyncPort.ofAddress(GetInterfaceAsyncPort$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceOpen$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceOpen$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.USBInterfaceOpen$FUNC
    );
    public interface USBInterfaceOpen {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(USBInterfaceOpen fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceOpen.class, fi, IOUSBInterfaceStruct190.USBInterfaceOpen$FUNC, session);
        }
        static USBInterfaceOpen ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.USBInterfaceOpen$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceOpen$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceOpen"));
    public static VarHandle USBInterfaceOpen$VH() {
        return IOUSBInterfaceStruct190.USBInterfaceOpen$VH;
    }
    public static MemoryAddress USBInterfaceOpen$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceOpen$VH.get(seg);
    }
    public static void USBInterfaceOpen$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceOpen$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceOpen$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceOpen$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceOpen$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceOpen$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceOpen USBInterfaceOpen (MemorySegment segment, MemorySession session) {
        return USBInterfaceOpen.ofAddress(USBInterfaceOpen$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceClose$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceClose$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.USBInterfaceClose$FUNC
    );
    public interface USBInterfaceClose {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(USBInterfaceClose fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceClose.class, fi, IOUSBInterfaceStruct190.USBInterfaceClose$FUNC, session);
        }
        static USBInterfaceClose ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.USBInterfaceClose$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceClose$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceClose"));
    public static VarHandle USBInterfaceClose$VH() {
        return IOUSBInterfaceStruct190.USBInterfaceClose$VH;
    }
    public static MemoryAddress USBInterfaceClose$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceClose$VH.get(seg);
    }
    public static void USBInterfaceClose$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceClose$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceClose$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceClose$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceClose$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceClose$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceClose USBInterfaceClose (MemorySegment segment, MemorySession session) {
        return USBInterfaceClose.ofAddress(USBInterfaceClose$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceClass$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceClass$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetInterfaceClass$FUNC
    );
    public interface GetInterfaceClass {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceClass.class, fi, IOUSBInterfaceStruct190.GetInterfaceClass$FUNC, session);
        }
        static GetInterfaceClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetInterfaceClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceClass"));
    public static VarHandle GetInterfaceClass$VH() {
        return IOUSBInterfaceStruct190.GetInterfaceClass$VH;
    }
    public static MemoryAddress GetInterfaceClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceClass$VH.get(seg);
    }
    public static void GetInterfaceClass$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceClass$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceClass$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceClass GetInterfaceClass (MemorySegment segment, MemorySession session) {
        return GetInterfaceClass.ofAddress(GetInterfaceClass$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceSubClass$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceSubClass$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetInterfaceSubClass$FUNC
    );
    public interface GetInterfaceSubClass {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceSubClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceSubClass.class, fi, IOUSBInterfaceStruct190.GetInterfaceSubClass$FUNC, session);
        }
        static GetInterfaceSubClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetInterfaceSubClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceSubClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceSubClass"));
    public static VarHandle GetInterfaceSubClass$VH() {
        return IOUSBInterfaceStruct190.GetInterfaceSubClass$VH;
    }
    public static MemoryAddress GetInterfaceSubClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceSubClass$VH.get(seg);
    }
    public static void GetInterfaceSubClass$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceSubClass$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceSubClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceSubClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceSubClass$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceSubClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceSubClass GetInterfaceSubClass (MemorySegment segment, MemorySession session) {
        return GetInterfaceSubClass.ofAddress(GetInterfaceSubClass$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceProtocol$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceProtocol$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetInterfaceProtocol$FUNC
    );
    public interface GetInterfaceProtocol {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceProtocol fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceProtocol.class, fi, IOUSBInterfaceStruct190.GetInterfaceProtocol$FUNC, session);
        }
        static GetInterfaceProtocol ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetInterfaceProtocol$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceProtocol$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceProtocol"));
    public static VarHandle GetInterfaceProtocol$VH() {
        return IOUSBInterfaceStruct190.GetInterfaceProtocol$VH;
    }
    public static MemoryAddress GetInterfaceProtocol$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceProtocol$VH.get(seg);
    }
    public static void GetInterfaceProtocol$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceProtocol$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceProtocol$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceProtocol$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceProtocol$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceProtocol$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceProtocol GetInterfaceProtocol (MemorySegment segment, MemorySession session) {
        return GetInterfaceProtocol.ofAddress(GetInterfaceProtocol$get(segment), session);
    }
    static final FunctionDescriptor GetDeviceVendor$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDeviceVendor$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetDeviceVendor$FUNC
    );
    public interface GetDeviceVendor {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDeviceVendor fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDeviceVendor.class, fi, IOUSBInterfaceStruct190.GetDeviceVendor$FUNC, session);
        }
        static GetDeviceVendor ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetDeviceVendor$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDeviceVendor$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDeviceVendor"));
    public static VarHandle GetDeviceVendor$VH() {
        return IOUSBInterfaceStruct190.GetDeviceVendor$VH;
    }
    public static MemoryAddress GetDeviceVendor$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDeviceVendor$VH.get(seg);
    }
    public static void GetDeviceVendor$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDeviceVendor$VH.set(seg, x);
    }
    public static MemoryAddress GetDeviceVendor$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDeviceVendor$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDeviceVendor$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDeviceVendor$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDeviceVendor GetDeviceVendor (MemorySegment segment, MemorySession session) {
        return GetDeviceVendor.ofAddress(GetDeviceVendor$get(segment), session);
    }
    static final FunctionDescriptor GetDeviceProduct$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDeviceProduct$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetDeviceProduct$FUNC
    );
    public interface GetDeviceProduct {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDeviceProduct fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDeviceProduct.class, fi, IOUSBInterfaceStruct190.GetDeviceProduct$FUNC, session);
        }
        static GetDeviceProduct ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetDeviceProduct$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDeviceProduct$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDeviceProduct"));
    public static VarHandle GetDeviceProduct$VH() {
        return IOUSBInterfaceStruct190.GetDeviceProduct$VH;
    }
    public static MemoryAddress GetDeviceProduct$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDeviceProduct$VH.get(seg);
    }
    public static void GetDeviceProduct$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDeviceProduct$VH.set(seg, x);
    }
    public static MemoryAddress GetDeviceProduct$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDeviceProduct$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDeviceProduct$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDeviceProduct$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDeviceProduct GetDeviceProduct (MemorySegment segment, MemorySession session) {
        return GetDeviceProduct.ofAddress(GetDeviceProduct$get(segment), session);
    }
    static final FunctionDescriptor GetDeviceReleaseNumber$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDeviceReleaseNumber$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetDeviceReleaseNumber$FUNC
    );
    public interface GetDeviceReleaseNumber {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDeviceReleaseNumber fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDeviceReleaseNumber.class, fi, IOUSBInterfaceStruct190.GetDeviceReleaseNumber$FUNC, session);
        }
        static GetDeviceReleaseNumber ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetDeviceReleaseNumber$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDeviceReleaseNumber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDeviceReleaseNumber"));
    public static VarHandle GetDeviceReleaseNumber$VH() {
        return IOUSBInterfaceStruct190.GetDeviceReleaseNumber$VH;
    }
    public static MemoryAddress GetDeviceReleaseNumber$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDeviceReleaseNumber$VH.get(seg);
    }
    public static void GetDeviceReleaseNumber$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDeviceReleaseNumber$VH.set(seg, x);
    }
    public static MemoryAddress GetDeviceReleaseNumber$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDeviceReleaseNumber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDeviceReleaseNumber$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDeviceReleaseNumber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDeviceReleaseNumber GetDeviceReleaseNumber (MemorySegment segment, MemorySession session) {
        return GetDeviceReleaseNumber.ofAddress(GetDeviceReleaseNumber$get(segment), session);
    }
    static final FunctionDescriptor GetConfigurationValue$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetConfigurationValue$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetConfigurationValue$FUNC
    );
    public interface GetConfigurationValue {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetConfigurationValue fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetConfigurationValue.class, fi, IOUSBInterfaceStruct190.GetConfigurationValue$FUNC, session);
        }
        static GetConfigurationValue ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetConfigurationValue$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetConfigurationValue$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetConfigurationValue"));
    public static VarHandle GetConfigurationValue$VH() {
        return IOUSBInterfaceStruct190.GetConfigurationValue$VH;
    }
    public static MemoryAddress GetConfigurationValue$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetConfigurationValue$VH.get(seg);
    }
    public static void GetConfigurationValue$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetConfigurationValue$VH.set(seg, x);
    }
    public static MemoryAddress GetConfigurationValue$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetConfigurationValue$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetConfigurationValue$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetConfigurationValue$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetConfigurationValue GetConfigurationValue (MemorySegment segment, MemorySession session) {
        return GetConfigurationValue.ofAddress(GetConfigurationValue$get(segment), session);
    }
    static final FunctionDescriptor GetInterfaceNumber$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetInterfaceNumber$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetInterfaceNumber$FUNC
    );
    public interface GetInterfaceNumber {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetInterfaceNumber fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetInterfaceNumber.class, fi, IOUSBInterfaceStruct190.GetInterfaceNumber$FUNC, session);
        }
        static GetInterfaceNumber ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetInterfaceNumber$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetInterfaceNumber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetInterfaceNumber"));
    public static VarHandle GetInterfaceNumber$VH() {
        return IOUSBInterfaceStruct190.GetInterfaceNumber$VH;
    }
    public static MemoryAddress GetInterfaceNumber$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceNumber$VH.get(seg);
    }
    public static void GetInterfaceNumber$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceNumber$VH.set(seg, x);
    }
    public static MemoryAddress GetInterfaceNumber$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetInterfaceNumber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetInterfaceNumber$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetInterfaceNumber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetInterfaceNumber GetInterfaceNumber (MemorySegment segment, MemorySession session) {
        return GetInterfaceNumber.ofAddress(GetInterfaceNumber$get(segment), session);
    }
    static final FunctionDescriptor GetAlternateSetting$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetAlternateSetting$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetAlternateSetting$FUNC
    );
    public interface GetAlternateSetting {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetAlternateSetting fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetAlternateSetting.class, fi, IOUSBInterfaceStruct190.GetAlternateSetting$FUNC, session);
        }
        static GetAlternateSetting ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetAlternateSetting$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetAlternateSetting$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetAlternateSetting"));
    public static VarHandle GetAlternateSetting$VH() {
        return IOUSBInterfaceStruct190.GetAlternateSetting$VH;
    }
    public static MemoryAddress GetAlternateSetting$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetAlternateSetting$VH.get(seg);
    }
    public static void GetAlternateSetting$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetAlternateSetting$VH.set(seg, x);
    }
    public static MemoryAddress GetAlternateSetting$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetAlternateSetting$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetAlternateSetting$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetAlternateSetting$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetAlternateSetting GetAlternateSetting (MemorySegment segment, MemorySession session) {
        return GetAlternateSetting.ofAddress(GetAlternateSetting$get(segment), session);
    }
    static final FunctionDescriptor GetNumEndpoints$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetNumEndpoints$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetNumEndpoints$FUNC
    );
    public interface GetNumEndpoints {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetNumEndpoints fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetNumEndpoints.class, fi, IOUSBInterfaceStruct190.GetNumEndpoints$FUNC, session);
        }
        static GetNumEndpoints ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetNumEndpoints$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetNumEndpoints$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetNumEndpoints"));
    public static VarHandle GetNumEndpoints$VH() {
        return IOUSBInterfaceStruct190.GetNumEndpoints$VH;
    }
    public static MemoryAddress GetNumEndpoints$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetNumEndpoints$VH.get(seg);
    }
    public static void GetNumEndpoints$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetNumEndpoints$VH.set(seg, x);
    }
    public static MemoryAddress GetNumEndpoints$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetNumEndpoints$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetNumEndpoints$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetNumEndpoints$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetNumEndpoints GetNumEndpoints (MemorySegment segment, MemorySession session) {
        return GetNumEndpoints.ofAddress(GetNumEndpoints$get(segment), session);
    }
    static final FunctionDescriptor GetLocationID$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetLocationID$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetLocationID$FUNC
    );
    public interface GetLocationID {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetLocationID fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetLocationID.class, fi, IOUSBInterfaceStruct190.GetLocationID$FUNC, session);
        }
        static GetLocationID ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetLocationID$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetLocationID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetLocationID"));
    public static VarHandle GetLocationID$VH() {
        return IOUSBInterfaceStruct190.GetLocationID$VH;
    }
    public static MemoryAddress GetLocationID$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetLocationID$VH.get(seg);
    }
    public static void GetLocationID$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetLocationID$VH.set(seg, x);
    }
    public static MemoryAddress GetLocationID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetLocationID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetLocationID$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetLocationID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetLocationID GetLocationID (MemorySegment segment, MemorySession session) {
        return GetLocationID.ofAddress(GetLocationID$get(segment), session);
    }
    static final FunctionDescriptor GetDevice$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDevice$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetDevice$FUNC
    );
    public interface GetDevice {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDevice fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDevice.class, fi, IOUSBInterfaceStruct190.GetDevice$FUNC, session);
        }
        static GetDevice ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetDevice$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDevice$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDevice"));
    public static VarHandle GetDevice$VH() {
        return IOUSBInterfaceStruct190.GetDevice$VH;
    }
    public static MemoryAddress GetDevice$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDevice$VH.get(seg);
    }
    public static void GetDevice$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDevice$VH.set(seg, x);
    }
    public static MemoryAddress GetDevice$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetDevice$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDevice$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetDevice$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDevice GetDevice (MemorySegment segment, MemorySession session) {
        return GetDevice.ofAddress(GetDevice$get(segment), session);
    }
    static final FunctionDescriptor SetAlternateInterface$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetAlternateInterface$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.SetAlternateInterface$FUNC
    );
    public interface SetAlternateInterface {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(SetAlternateInterface fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetAlternateInterface.class, fi, IOUSBInterfaceStruct190.SetAlternateInterface$FUNC, session);
        }
        static SetAlternateInterface ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.SetAlternateInterface$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetAlternateInterface$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetAlternateInterface"));
    public static VarHandle SetAlternateInterface$VH() {
        return IOUSBInterfaceStruct190.SetAlternateInterface$VH;
    }
    public static MemoryAddress SetAlternateInterface$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.SetAlternateInterface$VH.get(seg);
    }
    public static void SetAlternateInterface$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.SetAlternateInterface$VH.set(seg, x);
    }
    public static MemoryAddress SetAlternateInterface$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.SetAlternateInterface$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetAlternateInterface$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.SetAlternateInterface$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetAlternateInterface SetAlternateInterface (MemorySegment segment, MemorySession session) {
        return SetAlternateInterface.ofAddress(SetAlternateInterface$get(segment), session);
    }
    static final FunctionDescriptor GetBusFrameNumber$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBusFrameNumber$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetBusFrameNumber$FUNC
    );
    public interface GetBusFrameNumber {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetBusFrameNumber fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBusFrameNumber.class, fi, IOUSBInterfaceStruct190.GetBusFrameNumber$FUNC, session);
        }
        static GetBusFrameNumber ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetBusFrameNumber$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBusFrameNumber$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBusFrameNumber"));
    public static VarHandle GetBusFrameNumber$VH() {
        return IOUSBInterfaceStruct190.GetBusFrameNumber$VH;
    }
    public static MemoryAddress GetBusFrameNumber$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetBusFrameNumber$VH.get(seg);
    }
    public static void GetBusFrameNumber$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetBusFrameNumber$VH.set(seg, x);
    }
    public static MemoryAddress GetBusFrameNumber$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetBusFrameNumber$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBusFrameNumber$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetBusFrameNumber$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBusFrameNumber GetBusFrameNumber (MemorySegment segment, MemorySession session) {
        return GetBusFrameNumber.ofAddress(GetBusFrameNumber$get(segment), session);
    }
    static final FunctionDescriptor ControlRequest$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequest$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ControlRequest$FUNC
    );
    public interface ControlRequest {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ControlRequest fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequest.class, fi, IOUSBInterfaceStruct190.ControlRequest$FUNC, session);
        }
        static ControlRequest ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ControlRequest$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequest$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequest"));
    public static VarHandle ControlRequest$VH() {
        return IOUSBInterfaceStruct190.ControlRequest$VH;
    }
    public static MemoryAddress ControlRequest$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequest$VH.get(seg);
    }
    public static void ControlRequest$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequest$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequest$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequest$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequest$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequest$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequest ControlRequest (MemorySegment segment, MemorySession session) {
        return ControlRequest.ofAddress(ControlRequest$get(segment), session);
    }
    static final FunctionDescriptor ControlRequestAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequestAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ControlRequestAsync$FUNC
    );
    public interface ControlRequestAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(ControlRequestAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequestAsync.class, fi, IOUSBInterfaceStruct190.ControlRequestAsync$FUNC, session);
        }
        static ControlRequestAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ControlRequestAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequestAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequestAsync"));
    public static VarHandle ControlRequestAsync$VH() {
        return IOUSBInterfaceStruct190.ControlRequestAsync$VH;
    }
    public static MemoryAddress ControlRequestAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequestAsync$VH.get(seg);
    }
    public static void ControlRequestAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequestAsync$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequestAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequestAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequestAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequestAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequestAsync ControlRequestAsync (MemorySegment segment, MemorySession session) {
        return ControlRequestAsync.ofAddress(ControlRequestAsync$get(segment), session);
    }
    static final FunctionDescriptor GetPipeProperties$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPipeProperties$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetPipeProperties$FUNC
    );
    public interface GetPipeProperties {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(GetPipeProperties fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPipeProperties.class, fi, IOUSBInterfaceStruct190.GetPipeProperties$FUNC, session);
        }
        static GetPipeProperties ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetPipeProperties$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPipeProperties$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPipeProperties"));
    public static VarHandle GetPipeProperties$VH() {
        return IOUSBInterfaceStruct190.GetPipeProperties$VH;
    }
    public static MemoryAddress GetPipeProperties$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetPipeProperties$VH.get(seg);
    }
    public static void GetPipeProperties$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetPipeProperties$VH.set(seg, x);
    }
    public static MemoryAddress GetPipeProperties$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetPipeProperties$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPipeProperties$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetPipeProperties$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPipeProperties GetPipeProperties (MemorySegment segment, MemorySession session) {
        return GetPipeProperties.ofAddress(GetPipeProperties$get(segment), session);
    }
    static final FunctionDescriptor GetPipeStatus$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle GetPipeStatus$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetPipeStatus$FUNC
    );
    public interface GetPipeStatus {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(GetPipeStatus fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPipeStatus.class, fi, IOUSBInterfaceStruct190.GetPipeStatus$FUNC, session);
        }
        static GetPipeStatus ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetPipeStatus$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPipeStatus$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPipeStatus"));
    public static VarHandle GetPipeStatus$VH() {
        return IOUSBInterfaceStruct190.GetPipeStatus$VH;
    }
    public static MemoryAddress GetPipeStatus$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetPipeStatus$VH.get(seg);
    }
    public static void GetPipeStatus$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetPipeStatus$VH.set(seg, x);
    }
    public static MemoryAddress GetPipeStatus$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetPipeStatus$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPipeStatus$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetPipeStatus$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPipeStatus GetPipeStatus (MemorySegment segment, MemorySession session) {
        return GetPipeStatus.ofAddress(GetPipeStatus$get(segment), session);
    }
    static final FunctionDescriptor AbortPipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle AbortPipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.AbortPipe$FUNC
    );
    public interface AbortPipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(AbortPipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AbortPipe.class, fi, IOUSBInterfaceStruct190.AbortPipe$FUNC, session);
        }
        static AbortPipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.AbortPipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AbortPipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AbortPipe"));
    public static VarHandle AbortPipe$VH() {
        return IOUSBInterfaceStruct190.AbortPipe$VH;
    }
    public static MemoryAddress AbortPipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.AbortPipe$VH.get(seg);
    }
    public static void AbortPipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.AbortPipe$VH.set(seg, x);
    }
    public static MemoryAddress AbortPipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.AbortPipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AbortPipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.AbortPipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AbortPipe AbortPipe (MemorySegment segment, MemorySession session) {
        return AbortPipe.ofAddress(AbortPipe$get(segment), session);
    }
    static final FunctionDescriptor ResetPipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ResetPipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ResetPipe$FUNC
    );
    public interface ResetPipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(ResetPipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ResetPipe.class, fi, IOUSBInterfaceStruct190.ResetPipe$FUNC, session);
        }
        static ResetPipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ResetPipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ResetPipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ResetPipe"));
    public static VarHandle ResetPipe$VH() {
        return IOUSBInterfaceStruct190.ResetPipe$VH;
    }
    public static MemoryAddress ResetPipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ResetPipe$VH.get(seg);
    }
    public static void ResetPipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ResetPipe$VH.set(seg, x);
    }
    public static MemoryAddress ResetPipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ResetPipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ResetPipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ResetPipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ResetPipe ResetPipe (MemorySegment segment, MemorySession session) {
        return ResetPipe.ofAddress(ResetPipe$get(segment), session);
    }
    static final FunctionDescriptor ClearPipeStall$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ClearPipeStall$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ClearPipeStall$FUNC
    );
    public interface ClearPipeStall {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(ClearPipeStall fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ClearPipeStall.class, fi, IOUSBInterfaceStruct190.ClearPipeStall$FUNC, session);
        }
        static ClearPipeStall ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ClearPipeStall$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ClearPipeStall$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ClearPipeStall"));
    public static VarHandle ClearPipeStall$VH() {
        return IOUSBInterfaceStruct190.ClearPipeStall$VH;
    }
    public static MemoryAddress ClearPipeStall$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ClearPipeStall$VH.get(seg);
    }
    public static void ClearPipeStall$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ClearPipeStall$VH.set(seg, x);
    }
    public static MemoryAddress ClearPipeStall$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ClearPipeStall$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ClearPipeStall$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ClearPipeStall$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ClearPipeStall ClearPipeStall (MemorySegment segment, MemorySession session) {
        return ClearPipeStall.ofAddress(ClearPipeStall$get(segment), session);
    }
    static final FunctionDescriptor ReadPipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadPipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ReadPipe$FUNC
    );
    public interface ReadPipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(ReadPipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipe.class, fi, IOUSBInterfaceStruct190.ReadPipe$FUNC, session);
        }
        static ReadPipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ReadPipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipe"));
    public static VarHandle ReadPipe$VH() {
        return IOUSBInterfaceStruct190.ReadPipe$VH;
    }
    public static MemoryAddress ReadPipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipe$VH.get(seg);
    }
    public static void ReadPipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipe$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipe ReadPipe (MemorySegment segment, MemorySession session) {
        return ReadPipe.ofAddress(ReadPipe$get(segment), session);
    }
    static final FunctionDescriptor WritePipe$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle WritePipe$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.WritePipe$FUNC
    );
    public interface WritePipe {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(WritePipe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipe.class, fi, IOUSBInterfaceStruct190.WritePipe$FUNC, session);
        }
        static WritePipe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.WritePipe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipe"));
    public static VarHandle WritePipe$VH() {
        return IOUSBInterfaceStruct190.WritePipe$VH;
    }
    public static MemoryAddress WritePipe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipe$VH.get(seg);
    }
    public static void WritePipe$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipe$VH.set(seg, x);
    }
    public static MemoryAddress WritePipe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipe$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipe WritePipe (MemorySegment segment, MemorySession session) {
        return WritePipe.ofAddress(WritePipe$get(segment), session);
    }
    static final FunctionDescriptor ReadPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ReadPipeAsync$FUNC
    );
    public interface ReadPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(ReadPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipeAsync.class, fi, IOUSBInterfaceStruct190.ReadPipeAsync$FUNC, session);
        }
        static ReadPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ReadPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipeAsync"));
    public static VarHandle ReadPipeAsync$VH() {
        return IOUSBInterfaceStruct190.ReadPipeAsync$VH;
    }
    public static MemoryAddress ReadPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipeAsync$VH.get(seg);
    }
    public static void ReadPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipeAsync ReadPipeAsync (MemorySegment segment, MemorySession session) {
        return ReadPipeAsync.ofAddress(ReadPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor WritePipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WritePipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.WritePipeAsync$FUNC
    );
    public interface WritePipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5);
        static MemorySegment allocate(WritePipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipeAsync.class, fi, IOUSBInterfaceStruct190.WritePipeAsync$FUNC, session);
        }
        static WritePipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.WritePipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipeAsync"));
    public static VarHandle WritePipeAsync$VH() {
        return IOUSBInterfaceStruct190.WritePipeAsync$VH;
    }
    public static MemoryAddress WritePipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipeAsync$VH.get(seg);
    }
    public static void WritePipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress WritePipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipeAsync WritePipeAsync (MemorySegment segment, MemorySession session) {
        return WritePipeAsync.ofAddress(WritePipeAsync$get(segment), session);
    }
    static final FunctionDescriptor ReadIsochPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadIsochPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ReadIsochPipeAsync$FUNC
    );
    public interface ReadIsochPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, long _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(ReadIsochPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadIsochPipeAsync.class, fi, IOUSBInterfaceStruct190.ReadIsochPipeAsync$FUNC, session);
        }
        static ReadIsochPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, long __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ReadIsochPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadIsochPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadIsochPipeAsync"));
    public static VarHandle ReadIsochPipeAsync$VH() {
        return IOUSBInterfaceStruct190.ReadIsochPipeAsync$VH;
    }
    public static MemoryAddress ReadIsochPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadIsochPipeAsync$VH.get(seg);
    }
    public static void ReadIsochPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadIsochPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress ReadIsochPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadIsochPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadIsochPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadIsochPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadIsochPipeAsync ReadIsochPipeAsync (MemorySegment segment, MemorySession session) {
        return ReadIsochPipeAsync.ofAddress(ReadIsochPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor WriteIsochPipeAsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WriteIsochPipeAsync$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.WriteIsochPipeAsync$FUNC
    );
    public interface WriteIsochPipeAsync {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, long _x3, int _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(WriteIsochPipeAsync fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WriteIsochPipeAsync.class, fi, IOUSBInterfaceStruct190.WriteIsochPipeAsync$FUNC, session);
        }
        static WriteIsochPipeAsync ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, long __x3, int __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.WriteIsochPipeAsync$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WriteIsochPipeAsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WriteIsochPipeAsync"));
    public static VarHandle WriteIsochPipeAsync$VH() {
        return IOUSBInterfaceStruct190.WriteIsochPipeAsync$VH;
    }
    public static MemoryAddress WriteIsochPipeAsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WriteIsochPipeAsync$VH.get(seg);
    }
    public static void WriteIsochPipeAsync$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.WriteIsochPipeAsync$VH.set(seg, x);
    }
    public static MemoryAddress WriteIsochPipeAsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WriteIsochPipeAsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WriteIsochPipeAsync$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.WriteIsochPipeAsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WriteIsochPipeAsync WriteIsochPipeAsync (MemorySegment segment, MemorySession session) {
        return WriteIsochPipeAsync.ofAddress(WriteIsochPipeAsync$get(segment), session);
    }
    static final FunctionDescriptor ControlRequestTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequestTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ControlRequestTO$FUNC
    );
    public interface ControlRequestTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ControlRequestTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequestTO.class, fi, IOUSBInterfaceStruct190.ControlRequestTO$FUNC, session);
        }
        static ControlRequestTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ControlRequestTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequestTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequestTO"));
    public static VarHandle ControlRequestTO$VH() {
        return IOUSBInterfaceStruct190.ControlRequestTO$VH;
    }
    public static MemoryAddress ControlRequestTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequestTO$VH.get(seg);
    }
    public static void ControlRequestTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequestTO$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequestTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequestTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequestTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequestTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequestTO ControlRequestTO (MemorySegment segment, MemorySession session) {
        return ControlRequestTO.ofAddress(ControlRequestTO$get(segment), session);
    }
    static final FunctionDescriptor ControlRequestAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ControlRequestAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ControlRequestAsyncTO$FUNC
    );
    public interface ControlRequestAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(ControlRequestAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ControlRequestAsyncTO.class, fi, IOUSBInterfaceStruct190.ControlRequestAsyncTO$FUNC, session);
        }
        static ControlRequestAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ControlRequestAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ControlRequestAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ControlRequestAsyncTO"));
    public static VarHandle ControlRequestAsyncTO$VH() {
        return IOUSBInterfaceStruct190.ControlRequestAsyncTO$VH;
    }
    public static MemoryAddress ControlRequestAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequestAsyncTO$VH.get(seg);
    }
    public static void ControlRequestAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequestAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress ControlRequestAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ControlRequestAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ControlRequestAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ControlRequestAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ControlRequestAsyncTO ControlRequestAsyncTO (MemorySegment segment, MemorySession session) {
        return ControlRequestAsyncTO.ofAddress(ControlRequestAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor ReadPipeTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReadPipeTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ReadPipeTO$FUNC
    );
    public interface ReadPipeTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, int _x4, int _x5);
        static MemorySegment allocate(ReadPipeTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipeTO.class, fi, IOUSBInterfaceStruct190.ReadPipeTO$FUNC, session);
        }
        static ReadPipeTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, int __x4, int __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ReadPipeTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipeTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipeTO"));
    public static VarHandle ReadPipeTO$VH() {
        return IOUSBInterfaceStruct190.ReadPipeTO$VH;
    }
    public static MemoryAddress ReadPipeTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipeTO$VH.get(seg);
    }
    public static void ReadPipeTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipeTO$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipeTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipeTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipeTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipeTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipeTO ReadPipeTO (MemorySegment segment, MemorySession session) {
        return ReadPipeTO.ofAddress(ReadPipeTO$get(segment), session);
    }
    static final FunctionDescriptor WritePipeTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle WritePipeTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.WritePipeTO$FUNC
    );
    public interface WritePipeTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, int _x4, int _x5);
        static MemorySegment allocate(WritePipeTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipeTO.class, fi, IOUSBInterfaceStruct190.WritePipeTO$FUNC, session);
        }
        static WritePipeTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, int __x4, int __x5) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.WritePipeTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipeTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipeTO"));
    public static VarHandle WritePipeTO$VH() {
        return IOUSBInterfaceStruct190.WritePipeTO$VH;
    }
    public static MemoryAddress WritePipeTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipeTO$VH.get(seg);
    }
    public static void WritePipeTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipeTO$VH.set(seg, x);
    }
    public static MemoryAddress WritePipeTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipeTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipeTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipeTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipeTO WritePipeTO (MemorySegment segment, MemorySession session) {
        return WritePipeTO.ofAddress(WritePipeTO$get(segment), session);
    }
    static final FunctionDescriptor ReadPipeAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReadPipeAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ReadPipeAsyncTO$FUNC
    );
    public interface ReadPipeAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, int _x4, int _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(ReadPipeAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReadPipeAsyncTO.class, fi, IOUSBInterfaceStruct190.ReadPipeAsyncTO$FUNC, session);
        }
        static ReadPipeAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, int __x4, int __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ReadPipeAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReadPipeAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReadPipeAsyncTO"));
    public static VarHandle ReadPipeAsyncTO$VH() {
        return IOUSBInterfaceStruct190.ReadPipeAsyncTO$VH;
    }
    public static MemoryAddress ReadPipeAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipeAsyncTO$VH.get(seg);
    }
    public static void ReadPipeAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipeAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress ReadPipeAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ReadPipeAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReadPipeAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ReadPipeAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReadPipeAsyncTO ReadPipeAsyncTO (MemorySegment segment, MemorySession session) {
        return ReadPipeAsyncTO.ofAddress(ReadPipeAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor WritePipeAsyncTO$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle WritePipeAsyncTO$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.WritePipeAsyncTO$FUNC
    );
    public interface WritePipeAsyncTO {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, java.lang.foreign.MemoryAddress _x2, int _x3, int _x4, int _x5, java.lang.foreign.MemoryAddress _x6, java.lang.foreign.MemoryAddress _x7);
        static MemorySegment allocate(WritePipeAsyncTO fi, MemorySession session) {
            return RuntimeHelper.upcallStub(WritePipeAsyncTO.class, fi, IOUSBInterfaceStruct190.WritePipeAsyncTO$FUNC, session);
        }
        static WritePipeAsyncTO ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, java.lang.foreign.MemoryAddress __x2, int __x3, int __x4, int __x5, java.lang.foreign.MemoryAddress __x6, java.lang.foreign.MemoryAddress __x7) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.WritePipeAsyncTO$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, __x3, __x4, __x5, (java.lang.foreign.Addressable)__x6, (java.lang.foreign.Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle WritePipeAsyncTO$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WritePipeAsyncTO"));
    public static VarHandle WritePipeAsyncTO$VH() {
        return IOUSBInterfaceStruct190.WritePipeAsyncTO$VH;
    }
    public static MemoryAddress WritePipeAsyncTO$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipeAsyncTO$VH.get(seg);
    }
    public static void WritePipeAsyncTO$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipeAsyncTO$VH.set(seg, x);
    }
    public static MemoryAddress WritePipeAsyncTO$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.WritePipeAsyncTO$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WritePipeAsyncTO$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.WritePipeAsyncTO$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static WritePipeAsyncTO WritePipeAsyncTO (MemorySegment segment, MemorySession session) {
        return WritePipeAsyncTO.ofAddress(WritePipeAsyncTO$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceGetStringIndex$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceGetStringIndex$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$FUNC
    );
    public interface USBInterfaceGetStringIndex {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(USBInterfaceGetStringIndex fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceGetStringIndex.class, fi, IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$FUNC, session);
        }
        static USBInterfaceGetStringIndex ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceGetStringIndex$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceGetStringIndex"));
    public static VarHandle USBInterfaceGetStringIndex$VH() {
        return IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$VH;
    }
    public static MemoryAddress USBInterfaceGetStringIndex$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$VH.get(seg);
    }
    public static void USBInterfaceGetStringIndex$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceGetStringIndex$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceGetStringIndex$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceGetStringIndex$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceGetStringIndex USBInterfaceGetStringIndex (MemorySegment segment, MemorySession session) {
        return USBInterfaceGetStringIndex.ofAddress(USBInterfaceGetStringIndex$get(segment), session);
    }
    static final FunctionDescriptor USBInterfaceOpenSeize$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle USBInterfaceOpenSeize$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.USBInterfaceOpenSeize$FUNC
    );
    public interface USBInterfaceOpenSeize {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(USBInterfaceOpenSeize fi, MemorySession session) {
            return RuntimeHelper.upcallStub(USBInterfaceOpenSeize.class, fi, IOUSBInterfaceStruct190.USBInterfaceOpenSeize$FUNC, session);
        }
        static USBInterfaceOpenSeize ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.USBInterfaceOpenSeize$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle USBInterfaceOpenSeize$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("USBInterfaceOpenSeize"));
    public static VarHandle USBInterfaceOpenSeize$VH() {
        return IOUSBInterfaceStruct190.USBInterfaceOpenSeize$VH;
    }
    public static MemoryAddress USBInterfaceOpenSeize$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceOpenSeize$VH.get(seg);
    }
    public static void USBInterfaceOpenSeize$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceOpenSeize$VH.set(seg, x);
    }
    public static MemoryAddress USBInterfaceOpenSeize$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.USBInterfaceOpenSeize$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void USBInterfaceOpenSeize$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.USBInterfaceOpenSeize$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static USBInterfaceOpenSeize USBInterfaceOpenSeize (MemorySegment segment, MemorySession session) {
        return USBInterfaceOpenSeize.ofAddress(USBInterfaceOpenSeize$get(segment), session);
    }
    static final FunctionDescriptor ClearPipeStallBothEnds$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ClearPipeStallBothEnds$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.ClearPipeStallBothEnds$FUNC
    );
    public interface ClearPipeStallBothEnds {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1);
        static MemorySegment allocate(ClearPipeStallBothEnds fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ClearPipeStallBothEnds.class, fi, IOUSBInterfaceStruct190.ClearPipeStallBothEnds$FUNC, session);
        }
        static ClearPipeStallBothEnds ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.ClearPipeStallBothEnds$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ClearPipeStallBothEnds$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ClearPipeStallBothEnds"));
    public static VarHandle ClearPipeStallBothEnds$VH() {
        return IOUSBInterfaceStruct190.ClearPipeStallBothEnds$VH;
    }
    public static MemoryAddress ClearPipeStallBothEnds$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ClearPipeStallBothEnds$VH.get(seg);
    }
    public static void ClearPipeStallBothEnds$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.ClearPipeStallBothEnds$VH.set(seg, x);
    }
    public static MemoryAddress ClearPipeStallBothEnds$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.ClearPipeStallBothEnds$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ClearPipeStallBothEnds$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.ClearPipeStallBothEnds$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ClearPipeStallBothEnds ClearPipeStallBothEnds (MemorySegment segment, MemorySession session) {
        return ClearPipeStallBothEnds.ofAddress(ClearPipeStallBothEnds$get(segment), session);
    }
    static final FunctionDescriptor SetPipePolicy$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetPipePolicy$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.SetPipePolicy$FUNC
    );
    public interface SetPipePolicy {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, short _x2, byte _x3);
        static MemorySegment allocate(SetPipePolicy fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetPipePolicy.class, fi, IOUSBInterfaceStruct190.SetPipePolicy$FUNC, session);
        }
        static SetPipePolicy ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, short __x2, byte __x3) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.SetPipePolicy$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetPipePolicy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetPipePolicy"));
    public static VarHandle SetPipePolicy$VH() {
        return IOUSBInterfaceStruct190.SetPipePolicy$VH;
    }
    public static MemoryAddress SetPipePolicy$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.SetPipePolicy$VH.get(seg);
    }
    public static void SetPipePolicy$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.SetPipePolicy$VH.set(seg, x);
    }
    public static MemoryAddress SetPipePolicy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.SetPipePolicy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetPipePolicy$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.SetPipePolicy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetPipePolicy SetPipePolicy (MemorySegment segment, MemorySession session) {
        return SetPipePolicy.ofAddress(SetPipePolicy$get(segment), session);
    }
    static final FunctionDescriptor GetBandwidthAvailable$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBandwidthAvailable$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetBandwidthAvailable$FUNC
    );
    public interface GetBandwidthAvailable {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetBandwidthAvailable fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBandwidthAvailable.class, fi, IOUSBInterfaceStruct190.GetBandwidthAvailable$FUNC, session);
        }
        static GetBandwidthAvailable ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetBandwidthAvailable$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBandwidthAvailable$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBandwidthAvailable"));
    public static VarHandle GetBandwidthAvailable$VH() {
        return IOUSBInterfaceStruct190.GetBandwidthAvailable$VH;
    }
    public static MemoryAddress GetBandwidthAvailable$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetBandwidthAvailable$VH.get(seg);
    }
    public static void GetBandwidthAvailable$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetBandwidthAvailable$VH.set(seg, x);
    }
    public static MemoryAddress GetBandwidthAvailable$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetBandwidthAvailable$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBandwidthAvailable$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetBandwidthAvailable$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBandwidthAvailable GetBandwidthAvailable (MemorySegment segment, MemorySession session) {
        return GetBandwidthAvailable.ofAddress(GetBandwidthAvailable$get(segment), session);
    }
    static final FunctionDescriptor GetEndpointProperties$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetEndpointProperties$MH = RuntimeHelper.downcallHandle(
        IOUSBInterfaceStruct190.GetEndpointProperties$FUNC
    );
    public interface GetEndpointProperties {

        int apply(java.lang.foreign.MemoryAddress _x0, byte _x1, byte _x2, byte _x3, java.lang.foreign.MemoryAddress _x4, java.lang.foreign.MemoryAddress _x5, java.lang.foreign.MemoryAddress _x6);
        static MemorySegment allocate(GetEndpointProperties fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetEndpointProperties.class, fi, IOUSBInterfaceStruct190.GetEndpointProperties$FUNC, session);
        }
        static GetEndpointProperties ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, byte __x1, byte __x2, byte __x3, java.lang.foreign.MemoryAddress __x4, java.lang.foreign.MemoryAddress __x5, java.lang.foreign.MemoryAddress __x6) -> {
                try {
                    return (int)IOUSBInterfaceStruct190.GetEndpointProperties$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, __x2, __x3, (java.lang.foreign.Addressable)__x4, (java.lang.foreign.Addressable)__x5, (java.lang.foreign.Addressable)__x6);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetEndpointProperties$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetEndpointProperties"));
    public static VarHandle GetEndpointProperties$VH() {
        return IOUSBInterfaceStruct190.GetEndpointProperties$VH;
    }
    public static MemoryAddress GetEndpointProperties$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetEndpointProperties$VH.get(seg);
    }
    public static void GetEndpointProperties$set( MemorySegment seg, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetEndpointProperties$VH.set(seg, x);
    }
    public static MemoryAddress GetEndpointProperties$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)IOUSBInterfaceStruct190.GetEndpointProperties$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetEndpointProperties$set(MemorySegment seg, long index, MemoryAddress x) {
        IOUSBInterfaceStruct190.GetEndpointProperties$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetEndpointProperties GetEndpointProperties (MemorySegment segment, MemorySession session) {
        return GetEndpointProperties.ofAddress(GetEndpointProperties$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


